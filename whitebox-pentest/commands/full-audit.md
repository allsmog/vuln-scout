---
name: full-audit
description: End-to-end security audit - auto-scopes large codebases, threat models, and audits high-risk modules
argument-hint: "[path] [--quick] [--top N] [--recent days] [--language go|ts|py|java] [--focus types] [--exclude paths] [--min-severity level]"
allowed-tools:
  - Bash
  - Glob
  - Grep
  - Read
  - Write
  - TodoWrite
  - Task
  - AskUserQuestion
---

# Comprehensive Security Audit

**One command to audit any codebase, regardless of size.**

```
/whitebox-pentest:full-audit /path/to/code
```

This command automatically:
- Detects if codebase is too large for direct analysis
- Creates compressed architecture scope (language-aware)
- Generates system-level threat model
- Identifies and audits high-risk modules
- Produces actionable security report

## What This Command Does

```
┌─────────────────────────────────────────────────────────────┐
│                    FULL AUDIT PIPELINE                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Step 0: SIZE CHECK & ARCHITECTURE DISCOVERY                 │
│  └─> Measure tokens, parse docker-compose/supervisord       │
│  └─> Map services, ports, internal connectivity              │
│      < 150k tokens  → Direct audit                          │
│      > 150k tokens  → Architecture-first workflow           │
│                                                              │
│  Step 1: ARCHITECTURE SCOPE (if large)                       │
│  └─> Language-aware compression (Go: 97%, JS/TS: 80%)       │
│                                                              │
│  Step 1.5: FRAMEWORK PATTERN SCAN                            │
│  └─> Next.js Server Actions, Flask SSTI patterns            │
│  └─> Framework-specific security anti-patterns              │
│                                                              │
│  Step 2: THREAT MODEL                                        │
│  └─> STRIDE analysis, DFDs, trust boundaries                │
│                                                              │
│  Step 3: MODULE IDENTIFICATION                               │
│  └─> Rank modules by risk, select top N                     │
│                                                              │
│  Step 4: DEEP DIVE AUDIT (per module)                        │
│  └─> Sink search, data flow tracing, verification           │
│                                                              │
│  Step 5: CHAIN ANALYSIS                                      │
│  └─> Connect SSRF to internal SSTI/SQLi                     │
│  └─> Map pivot points to high-impact sinks                  │
│                                                              │
│  Step 6: REPORT                                              │
│  └─> Comprehensive findings with remediation                │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

---

## Usage

### Full Audit (Recommended)
```
/whitebox-pentest:full-audit /path/to/code
```

### Quick Audit (Skip threat modeling)
```
/whitebox-pentest:full-audit /path/to/code --quick
```

### Audit Top 5 Modules (default is 3)
```
/whitebox-pentest:full-audit /path/to/code --top 5
```

### Focus on Recent Changes (git-aware)
```
/whitebox-pentest:full-audit /path/to/code --recent 30
```
Prioritizes modules with changes in the last 30 days. New code has higher vulnerability density.

### Specify Language (auto-detected if omitted)
```
/whitebox-pentest:full-audit /path/to/code --language go
```

---

## Prerequisites

### Validate Dependencies

```bash
# Check repomix (required for scoping large codebases)
if ! command -v npx &> /dev/null || ! npx repomix --version &> /dev/null; then
  echo "Error: repomix required. Install with: npm install -g repomix"
  exit 1
fi

# Check target path exists
if [ ! -d "[path]" ]; then
  echo "Error: Target path does not exist: [path]"
  exit 1
fi

# Ensure .claude output directory exists
mkdir -p .claude
```

---

## Critical Rules

### RULE 1: Never Stop at First Critical
**ALWAYS audit ALL components even after finding critical vulnerabilities.**

A critical in one component does NOT mean other components are safe. In fact, vulnerabilities often chain across components (e.g., SSRF in frontend → SSTI in backend → RCE).

❌ **Wrong**: Find SSTI in Flask backend → Stop scanning → Miss SSRF in Next.js
✅ **Correct**: Find SSTI in Flask → Continue → Find SSRF in Next.js → Report chain

### RULE 2: Explicit Coverage Reporting
**ALWAYS report what was analyzed vs skipped in the final report.**

Every audit report MUST include a coverage section:
```markdown
## Coverage Report

| Component | Language | Files | Status | Notes |
|-----------|----------|-------|--------|-------|
| av/ (Flask backend) | Python | 12 | ✅ Analyzed | SSTI found |
| front-end/ (Next.js) | TypeScript | 24 | ✅ Analyzed | Server Actions reviewed |
| shared/utils | JavaScript | 3 | ⚠️ Partial | Only auth.js reviewed |
| docs/ | Markdown | 15 | ⏭️ Skipped | Documentation only |
```

### RULE 3: Multi-Framework Parity
**Analyze ALL frameworks with equal depth.**

When multiple frameworks are detected:
1. Apply framework-specific patterns to EACH (see `framework-patterns` skill)
2. Check Next.js: Server Actions, Route Handlers, middleware bypass
3. Check Flask: SSTI, debug mode, secret key, deserialization
4. Check for cross-framework chains (SSRF → internal service exploitation)

### RULE 4: Next.js Server Action SSRF Check
**If Next.js is detected, ALWAYS check for Server Actions with redirect().**

This is a known SSRF vector. When you find `"use server"` + `redirect()`:
1. Read the Server Action file
2. Report it as: "Potential SSRF via Server Action redirect()" with severity HIGH
3. Note: Attacker can manipulate Host header to make Next.js fetch attacker-controlled URL

---

## Workflow

### PRE-FLIGHT: Mandatory Framework Detection (RUN FIRST)

## ⚠️ MANDATORY EXECUTION REQUIREMENT ⚠️

**STOP AND READ THIS FIRST**. You MUST execute the following commands using the Bash tool BEFORE proceeding with any analysis. This is NOT optional documentation - these are REQUIRED tool invocations.

**STEP 1**: Execute this command NOW:

```bash
echo "=== PRE-FLIGHT FRAMEWORK CHECK ===" && \
if [ -f "[path]/package.json" ] && grep -q '"next"' "[path]/package.json" 2>/dev/null; then \
  echo "NEXT.JS DETECTED" && \
  echo "Server Actions:" && grep -rn '"use server"' --include="*.ts" --include="*.tsx" "[path]" 2>/dev/null | head -10; \
  echo "Redirects:" && grep -rn 'redirect(' --include="*.ts" --include="*.tsx" "[path]" 2>/dev/null | head -10; \
fi && \
if grep -qi 'flask' "[path]/requirements.txt" 2>/dev/null; then \
  echo "FLASK DETECTED" && \
  echo "SSTI sinks:" && grep -rn 'render_template_string' --include="*.py" "[path]" 2>/dev/null; \
fi && \
if find "[path]" -name "*.sol" -type f 2>/dev/null | grep -q .; then \
  echo "SOLIDITY DETECTED - Running reentrancy checks" && \
  echo "External calls:" && grep -rn '\.call{value:' --include="*.sol" "[path]" 2>/dev/null | head -10; \
  echo "CEI violations (state change after call):" && rg -U "\.call\{value:.*\n.*delete\|\.call\{value:.*\n.*-=" --glob "*.sol" "[path]" 2>/dev/null | head -10; \
  echo "Reentrancy guards:" && grep -rn 'nonReentrant\|ReentrancyGuard' --include="*.sol" "[path]" 2>/dev/null | head -5; \
fi
```

**STEP 2**: Report ALL vulnerabilities found in EACH framework. If Next.js has Server Actions with redirect(), report it as a potential SSRF. If Flask has render_template_string(), report it as SSTI.

---

**Full detection script (for reference)**:

```bash
# RUN THIS FIRST - Framework Detection
echo "=== MANDATORY PRE-FLIGHT FRAMEWORK CHECK ==="

# Check for Next.js
NEXTJS_DETECTED="false"
if [ -f "[path]/package.json" ] && grep -q '"next"' "[path]/package.json" 2>/dev/null; then
  NEXTJS_DETECTED="true"
  echo "✓ NEXT.JS DETECTED - Will run Server Action/SSRF checks"

  # Immediately find Server Actions with redirect
  echo "  Checking for SSRF vectors (redirect in Server Actions)..."
  grep -rn '"use server"' --include="*.ts" --include="*.tsx" "[path]" 2>/dev/null || echo "  No Server Actions found"
  grep -rn 'redirect(' --include="*.ts" --include="*.tsx" "[path]" 2>/dev/null || echo "  No redirect() calls found"
fi

# Check for Flask
FLASK_DETECTED="false"
if [ -f "[path]/requirements.txt" ] && grep -qi 'flask' "[path]/requirements.txt" 2>/dev/null; then
  FLASK_DETECTED="true"
  echo "✓ FLASK DETECTED - Will run SSTI/template injection checks"

  # Immediately find SSTI sinks
  echo "  Checking for SSTI sinks..."
  grep -rn 'render_template_string' --include="*.py" "[path]" 2>/dev/null || echo "  No render_template_string found"
fi

# Check for Solidity (Smart Contracts)
SOLIDITY_DETECTED="false"
if find "[path]" -name "*.sol" -type f 2>/dev/null | grep -q .; then
  SOLIDITY_DETECTED="true"
  echo "✓ SOLIDITY DETECTED - Will run reentrancy/CEI pattern checks"

  # Count Solidity files
  sol_count=$(find "[path]" -name "*.sol" -type f 2>/dev/null | wc -l)
  echo "  Found $sol_count Solidity files"

  # Immediately check for reentrancy patterns
  echo "  Checking for external calls (reentrancy vectors)..."
  grep -rn '\.call{value:' --include="*.sol" "[path]" 2>/dev/null | head -10 || echo "  No .call{value:} found"

  # Check for CEI violations (the critical pattern)
  echo "  Checking for CEI violations (state change AFTER external call)..."
  rg -U "\.call\{value:[^}]*\}[^;]*;[\s\S]{0,100}(delete\s+\w+|\w+\s*-=)" --glob "*.sol" "[path]" 2>/dev/null | head -5 || echo "  No obvious CEI violations found (manual review still recommended)"

  # Check for reentrancy guards
  echo "  Checking for reentrancy guards..."
  guard_count=$(grep -rn 'nonReentrant\|ReentrancyGuard' --include="*.sol" "[path]" 2>/dev/null | wc -l)
  if [ "$guard_count" -gt 0 ]; then
    echo "  ✓ Found $guard_count reentrancy guard(s)"
  else
    echo "  ⚠️  NO REENTRANCY GUARDS FOUND - Manual CEI pattern review required!"
  fi

  # Check for token callbacks (often missed reentrancy vectors)
  echo "  Checking for token callbacks (ERC721/777/1155 reentrancy)..."
  grep -rn 'safeTransfer\|safeMint\|onERC721Received\|tokensReceived' --include="*.sol" "[path]" 2>/dev/null | head -5 || echo "  No token callbacks found"
fi

# Multi-framework chain warning
if [ "$NEXTJS_DETECTED" = "true" ] && [ "$FLASK_DETECTED" = "true" ]; then
  echo ""
  echo "⚠️  MULTI-FRAMEWORK ARCHITECTURE DETECTED"
  echo "   CRITICAL: Check for SSRF → SSTI attack chains!"
  echo "   Next.js redirect() can be exploited to reach internal Flask SSTI"
  echo ""
fi

# Solidity-specific warning
if [ "$SOLIDITY_DETECTED" = "true" ]; then
  echo ""
  echo "⚠️  SMART CONTRACT AUDIT MODE"
  echo "   CRITICAL: All .call{value:} must follow CEI pattern (Checks-Effects-Interactions)"
  echo "   CRITICAL: State changes MUST happen BEFORE external calls"
  echo "   See: skills/dangerous-functions/references/solidity-sinks.md"
  echo "   See: skills/vuln-patterns/references/reentrancy-solidity.md"
  echo ""
fi

echo "=== END PRE-FLIGHT ==="
```

---

### Step 0: Size Check & Strategy Selection

**Goal**: Determine if codebase needs architecture-first approach

```bash
# Measure token count
npx repomix [path] --style markdown -o /dev/null 2>&1 | grep "Total Tokens"
```

**Decision Matrix:**

| Tokens | Strategy | What Happens |
|--------|----------|--------------|
| < 50k | Direct Audit | Skip to Step 4 (full code analysis) |
| 50k - 150k | Direct + Scope | Create scope, run full audit |
| 150k - 300k | Architecture-First | Steps 1-5 (recommended) |
| > 300k | Architecture-First | Steps 1-5 (required) |

**Output**: Strategy decision displayed to user

### Step 0.5: Polyglot Detection (Automatic)

**Goal**: Automatically identify if codebase is mixed-language and switch to per-service workflow

```bash
# Count files by language
go_count=$(find [path] -name '*.go' ! -path '*/vendor/*' ! -name '*_test.go' 2>/dev/null | wc -l)
py_count=$(find [path] -name '*.py' ! -path '*/.venv/*' ! -name 'test_*.py' 2>/dev/null | wc -l)
ts_count=$(find [path] \( -name '*.ts' -o -name '*.tsx' \) ! -path '*/node_modules/*' ! -name '*.test.*' 2>/dev/null | wc -l)
java_count=$(find [path] -name '*.java' ! -path '*/test/*' ! -name '*Test.java' 2>/dev/null | wc -l)
rs_count=$(find [path] -name '*.rs' ! -path '*/target/*' 2>/dev/null | wc -l)
sol_count=$(find [path] -name '*.sol' ! -path '*/node_modules/*' 2>/dev/null | wc -l)
```

**Polyglot Detection Criteria** (automatic):
- 2+ languages have >50 source files each → **Polyglot detected**
- Multiple `Dockerfile`s in different directories → **Polyglot likely**
- Multiple package managers (go.mod + package.json + requirements.txt) → **Polyglot likely**

When polyglot is detected, the workflow automatically switches to per-service analysis.

**If Polyglot Detected:**

1. **Map services to languages:**
   ```bash
   # Find service boundaries
   find [path] -name 'main.go' -o -name 'main.py' -o -name '*Application.java' 2>/dev/null
   find [path] -name 'Dockerfile*' 2>/dev/null
   ```

2. **Generate service map:**
   ```markdown
   | Service | Path | Language | Est. Tokens | Risk |
   |---------|------|----------|-------------|------|
   | api-gateway | services/gateway/ | Go | 85k | HIGH |
   | ml-service | services/ml/ | Python | 120k | HIGH |
   | frontend | apps/web/ | TypeScript | 200k | MEDIUM |
   ```

3. **Detect inter-service communication:**
   ```bash
   # Protocol definitions
   find [path] -name '*.proto' -o -name 'openapi*.yaml' -o -name '*.graphql'
   ```

4. **Switch to per-service audit workflow** (see Polyglot Workflow below)

**Output**: Service map and recommended audit order

### Step 1: Language Detection & Framework Security Scan

**Goal**: Detect frameworks and run MANDATORY security checks for each

```bash
# Auto-detect primary language
ts_count=$(find [path] -name "*.ts" -o -name "*.tsx" 2>/dev/null | wc -l)
go_count=$(find [path] -name "*.go" 2>/dev/null | wc -l)
py_count=$(find [path] -name "*.py" 2>/dev/null | wc -l)
java_count=$(find [path] -name "*.java" 2>/dev/null | wc -l)
php_count=$(find [path] -name "*.php" 2>/dev/null | wc -l)
cs_count=$(find [path] -name "*.cs" 2>/dev/null | wc -l)
rb_count=$(find [path] -name "*.rb" 2>/dev/null | wc -l)
rs_count=$(find [path] -name "*.rs" 2>/dev/null | wc -l)
sol_count=$(find [path] -name "*.sol" 2>/dev/null | wc -l)
```

#### MANDATORY Framework Security Checks

**Run these checks IMMEDIATELY after detecting frameworks. Do NOT skip.**

**Next.js Detection & Checks:**
```bash
# Detect Next.js
if grep -q '"next"' package.json 2>/dev/null; then
  echo "Next.js DETECTED - Running MANDATORY security checks..."

  # CHECK 1: Server Actions with redirect() - CRITICAL SSRF RISK
  echo "=== Checking Server Actions with redirect ==="
  grep -rn '"use server"' --include="*.ts" --include="*.tsx" [path]
  grep -rn 'redirect(' --include="*.ts" --include="*.tsx" [path]

  # CHECK 2: Route Handlers
  echo "=== Checking Route Handlers ==="
  find [path] -path "*/app/api/*" \( -name "route.ts" -o -name "route.tsx" \)

  # CHECK 3: Middleware
  echo "=== Checking Middleware ==="
  find [path] -name "middleware.ts" -o -name "middleware.tsx"
fi
```

**Flask Detection & Checks:**
```bash
# Detect Flask
if grep -q 'flask' requirements.txt 2>/dev/null || find [path] -name "app.py" | grep -q .; then
  echo "Flask DETECTED - Running MANDATORY security checks..."

  # CHECK 1: SSTI sinks - CRITICAL
  echo "=== Checking SSTI sinks ==="
  grep -rn 'render_template_string' --include="*.py" [path]

  # CHECK 2: Debug mode
  echo "=== Checking debug mode ==="
  grep -rn 'debug.*True' --include="*.py" [path]
fi
```

**Symfony/Twig Detection & Checks:**
```bash
# Detect Symfony/Twig (PHP)
if [ -f "[path]/symfony.lock" ] || grep -q 'twig/twig' "[path]/composer.json" 2>/dev/null; then
  echo "SYMFONY/TWIG DETECTED - Running MANDATORY security checks..."

  # CHECK 1: Twig SSTI via createTemplate - CRITICAL
  echo "=== Checking Twig SSTI sinks ==="
  grep -rn 'createTemplate\|->render(' --include="*.php" [path]

  # CHECK 2: Check disable_functions (critical for bypass)
  echo "=== Checking disable_functions bypass vectors ==="
  grep -rn 'file_put_contents\|copy\|symlink\|chmod' --include="*.php" [path]

  # CHECK 3: Apache AllowOverride for CGI bypass
  echo "=== Checking Apache CGI configuration ==="
  grep -rn 'AllowOverride\|Options.*ExecCGI\|AddHandler.*cgi' --include="*.conf" [path]

  # CHECK 4: Twig filter callbacks - can invoke PHP functions
  echo "=== Twig filter exploitation note ==="
  echo "CRITICAL: Twig sort/map/filter/reduce filters accept PHP function callbacks"
  echo "Example: {{[path,content]|sort('file_put_contents')}} calls file_put_contents(path,content)"
fi
```

**Cross-Component Chain Check (if multiple frameworks detected):**
```bash
# If BOTH Next.js AND Flask/Python backend detected
if [[ -f package.json ]] && grep -q '"next"' package.json && [[ -f requirements.txt ]]; then
  echo "MULTI-FRAMEWORK DETECTED - Checking for attack chains..."

  # Check orchestration for internal connectivity
  cat docker-compose.yml supervisord.conf 2>/dev/null

  # CRITICAL: If Next.js has redirect() AND Flask has render_template_string()
  # This is a potential SSRF → SSTI → RCE chain!
  echo "=== CHAIN CHECK: SSRF → SSTI ==="
  echo "Next.js redirect() can be exploited to reach internal Flask SSTI"
fi
```

#### Architecture Scope (for large codebases)

**Language-Specific Compression:**

| Language | Strategy | Expected Reduction |
|----------|----------|-------------------|
| Go | Directory-based filtering (interfaces/, handler/, svc/) | **95-97%** |
| TypeScript/JS | Tree-sitter compression | ~80% |
| Python | Framework-aware filtering (views/, api/, models/, schemas/) | **85-90%** |
| Java | Spring pattern filtering (Controller, Service, Repository) | **80-85%** |
| Rust | Module-based filtering (lib.rs, mod.rs, handlers/, traits/) | **85-90%** |
| PHP | Laravel/Symfony patterns (Controllers/, Models/, routes/) | **80-85%** |
| C#/.NET | ASP.NET Core patterns (Controllers/, Services/, Middleware/) | **80-85%** |
| Ruby | Rails patterns (controllers/, models/, services/) | **85-90%** |
| Solidity | Contract filtering (contracts/, interfaces/, libraries/) | **70-80%** |

**Go compression command:**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/interfaces/**/*.go,**/handler/**/*.go,**/svc/**/*.go,**/proto/*.go,**/errors/*.go,**/client/**/*.go,**/api/**/*.go,**/types/**/*.go,**/model/**/*.go" \
  --ignore "*_test.go,**/testing/**,**/testdata/**,**/*.pb.go,**/*_mock.go" \
  --output .claude/scope-architecture.md
```

**Python compression command (Django/Flask/FastAPI):**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/views/**/*.py,**/api/**/*.py,**/routes/**/*.py,**/endpoints/**/*.py,**/routers/**/*.py,**/models/**/*.py,**/schemas/**/*.py,**/serializers/**/*.py,**/services/**/*.py,**/handlers/**/*.py,**/middleware/**/*.py,**/auth/**/*.py,**/core/**/*.py" \
  --ignore "**/*_test.py,**/test_*.py,**/tests/**,**/__pycache__/**,**/migrations/**,**/.venv/**" \
  --output .claude/scope-architecture.md
```

**Java compression command (Spring):**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/*Controller*.java,**/*Service*.java,**/*ServiceImpl*.java,**/*Repository*.java,**/*Api*.java,**/*Handler*.java,**/*Filter*.java,**/*Config*.java,**/model/**/*.java,**/dto/**/*.java,**/entity/**/*.java,**/security/**/*.java" \
  --ignore "**/test/**,**/*Test.java,**/*Tests.java,**/target/**" \
  --output .claude/scope-architecture.md
```

**Rust compression command:**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/lib.rs,**/mod.rs,**/api/**/*.rs,**/handlers/**/*.rs,**/routes/**/*.rs,**/services/**/*.rs,**/models/**/*.rs,**/auth/**/*.rs,**/middleware/**/*.rs,**/types/**/*.rs,**/traits/**/*.rs" \
  --ignore "**/target/**,**/*_test.rs,**/tests/**,**/benches/**" \
  --output .claude/scope-architecture.md
```

**PHP compression command (Laravel/Symfony):**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/app/Http/Controllers/**/*.php,**/app/Http/Middleware/**/*.php,**/app/Models/**/*.php,**/app/Services/**/*.php,**/routes/**/*.php,**/src/Controller/**/*.php,**/src/Entity/**/*.php,**/src/Service/**/*.php,**/src/Security/**/*.php" \
  --ignore "**/vendor/**,**/tests/**,**/*Test.php,**/cache/**,**/storage/**" \
  --output .claude/scope-architecture.md
```

**C#/.NET compression command (ASP.NET Core):**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/*Controller*.cs,**/Controllers/**/*.cs,**/Services/**/*.cs,**/Repositories/**/*.cs,**/Models/**/*.cs,**/Middleware/**/*.cs,**/Authorization/**/*.cs,**/*Service.cs,**/Program.cs,**/Startup.cs" \
  --ignore "**/bin/**,**/obj/**,**/tests/**,**/*Test*.cs,**/packages/**" \
  --output .claude/scope-architecture.md
```

**Ruby compression command (Rails):**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/app/controllers/**/*.rb,**/app/models/**/*.rb,**/app/services/**/*.rb,**/app/policies/**/*.rb,**/config/routes.rb,**/config/initializers/**/*.rb,**/lib/**/*.rb" \
  --ignore "**/vendor/**,**/spec/**,**/test/**,**/*_spec.rb,**/*_test.rb,**/tmp/**" \
  --output .claude/scope-architecture.md
```

**Solidity compression command (Smart Contracts):**
```bash
npx repomix [path] --compress --style markdown \
  --include "**/*.sol,**/contracts/**/*.sol,**/src/**/*.sol,**/interfaces/**/*.sol,**/libraries/**/*.sol" \
  --ignore "**/node_modules/**,**/test/**,**/*Test.sol,**/mocks/**,**/forge-std/**" \
  --output .claude/scope-architecture.md
```

**Output**: `.claude/scope-architecture.md`

### Step 2: Threat Modeling

**Goal**: Systematic threat identification via STRIDE

Using the compressed architecture scope:
1. Identify components (services, handlers, data stores)
2. Map trust boundaries between components
3. Generate data flow diagrams (Mermaid)
4. Perform STRIDE analysis per component
5. Risk scoring (Impact x Likelihood)

**Output**: `.claude/threat-model.md`

### Step 3: High-Risk Module Identification

**Goal**: Select modules for deep-dive audit

**Scoring Criteria:**
| Factor | Points |
|--------|--------|
| Has CRITICAL threats | +50 |
| Has HIGH threats | +30 |
| Is entry point (handler/route) | +20 |
| Has external integrations | +20 |
| Handles auth/secrets | +30 |
| Token count < 150k | +10 |

**Output**: Ranked list of modules, top N selected for audit

### Step 4: Deep Dive Audit (Per Module)

**Goal**: Detailed vulnerability hunting with architecture context

**IMPORTANT**: Audit ALL modules, even after finding critical issues. Never stop early.

For each selected module:

1. **Create module scope**:
   ```bash
   npx repomix [module-path] --style markdown --output .claude/scope-[module].md
   ```

2. **Load architecture context** from threat model:
   - Trust boundaries this module crosses
   - Threats mapped to this module
   - Cross-module data flows

3. **Apply framework-specific patterns** (MANDATORY for each detected framework):

   **If Next.js detected** (package.json contains "next"):
   ```bash
   # MUST CHECK: Server Actions with redirect (SSRF vulnerability)
   grep -rn '"use server"' --include="*.ts" --include="*.tsx" | head -20
   grep -rn 'from.*next/navigation.*redirect' --include="*.ts" --include="*.tsx"
   grep -rn 'redirect(' --include="*.ts" --include="*.tsx"

   # MUST CHECK: Route Handlers without auth
   find . -path "*/app/api/*" -name "route.ts" -o -name "route.tsx" 2>/dev/null

   # MUST CHECK: Server Actions callable externally
   grep -rn 'export async function' --include="*.ts" --include="*.tsx" | grep -v node_modules
   ```
   **CRITICAL**: Server Actions using redirect() can be exploited via Host header manipulation for SSRF!

   **If Flask detected** (requirements.txt contains "flask" or app.py exists):
   ```bash
   # MUST CHECK: SSTI sinks
   grep -rn 'render_template_string' --include="*.py"
   grep -rn 'Template(' --include="*.py"

   # MUST CHECK: Debug mode
   grep -rn 'debug.*=.*True' --include="*.py"
   ```

   **If both Next.js AND Flask detected** (multi-service):
   ```bash
   # MUST CHECK: Cross-component chain potential
   # 1. Can Next.js SSRF reach Flask?
   cat docker-compose.yml supervisord.conf 2>/dev/null | grep -E "port|command"
   # 2. Does Flask have SSTI that SSRF could reach?
   # If YES → Document as CRITICAL chain: SSRF → SSTI → RCE
   ```

   **If PHP/Symfony/Twig detected**:
   ```bash
   # MUST CHECK: Twig SSTI + disable_functions bypass chain
   # 1. Find SSTI sinks
   grep -rn 'createTemplate' --include="*.php" [module-path]

   # 2. Check for filter callback exploitation
   # Twig filters sort/map/filter/reduce can call any PHP function
   # {{[arg1, arg2]|sort('function_name')}} → calls function_name(arg1, arg2)

   # 3. Check for file write primitives (rarely in disable_functions)
   grep -rn 'file_put_contents\|copy\|symlink' --include="*.php" [module-path]

   # 4. Check Apache AllowOverride for CGI bypass
   grep -rn 'AllowOverride All\|Options.*ExecCGI' --include="*.conf" [module-path]

   # If SSTI + file_put_contents available + AllowOverride:
   # → Document as CRITICAL chain: SSTI → sort('file_put_contents') → .htaccess → CGI → RCE
   ```
   See `skills/framework-patterns/twig-patterns.md` and `skills/dangerous-functions/disable-functions-bypass.md` for detailed exploitation chains.

4. **Run sink search**:
   - Dangerous function patterns (exec, query, serialize)
   - Language-specific sinks

5. **Trace data flows**:
   - Source to sink analysis
   - Filter/sanitization verification

6. **Document findings** with severity and remediation

**Output**: Findings per module

### Step 5: Cross-Component Chain Analysis

**Goal**: Connect vulnerabilities across service boundaries (see `vulnerability-chains` skill)

1. **Map SSRF sources** in external services:
   - Next.js redirect(), fetch with user URL
   - API endpoints that make outbound requests

2. **Map high-impact sinks** in internal services:
   - SSTI (render_template_string, Template)
   - Unsafe deserialization
   - Command injection (exec, spawn, system)

3. **Connect pivots to sinks**:
   - Can SSRF reach internal SSTI endpoint?
   - Does user input flow from pivot to sink?
   - What filters/sanitization exist in the path?

4. **Document chains**:
   ```markdown
   ## Chain: SSRF → SSTI → RCE
   - Entry: Next.js Server Action redirect (external)
   - Pivot: Host header SSRF
   - Sink: Flask render_template_string (internal)
   - Impact: Remote Code Execution
   ```

**Output**: Chain findings added to report

### Step 6: Report Generation

**Goal**: Actionable security report with coverage transparency

```
1. Generate COVERAGE REPORT (mandatory)
2. Aggregate findings from all modules
3. Include cross-component chains
4. Include architecture diagrams from threat model
5. Sort by severity and verification confidence
6. Include specific remediation guidance
7. Generate executive summary
```

**Coverage Report** (REQUIRED in every report):
```markdown
## Coverage Report

| Component | Language | Files | Status | Findings |
|-----------|----------|-------|--------|----------|
| frontend/ | Next.js/TS | 24 | ✅ Analyzed | 1 HIGH |
| backend/ | Flask/Python | 12 | ✅ Analyzed | 1 CRITICAL |
| shared/ | JavaScript | 5 | ✅ Analyzed | None |
| docs/ | Markdown | 10 | ⏭️ Skipped | N/A |

Total: 41 files analyzed, 10 skipped
```

**Report Guidelines**:
- Document vulnerability building blocks, not ready-to-use exploits
- Show "Vulnerability Connections" section for chains
- Include verification checklist for multi-step attack chains
- Let analysts verify before developing working exploits

**Output**: `.claude/audit-report.md`

### Step 7: JSON Findings Export (MANDATORY)

**Goal**: Generate machine-readable findings for integration with security tools

After generating the markdown report, you MUST also create a structured JSON file:

**Output File**: `.claude/findings.json`

**JSON Schema** (REQUIRED - follow this exactly):
```json
{
  "scan_id": "uuid-v4",
  "project_path": "/path/to/project",
  "completed_at": "2024-01-15T10:30:00Z",
  "summary": {
    "total": 7,
    "critical": 3,
    "high": 2,
    "medium": 1,
    "low": 1,
    "info": 0
  },
  "findings": [
    {
      "id": "VULN-001",
      "title": "SQL Injection in getUser()",
      "severity": "critical",
      "cwe_id": "CWE-89",
      "file_path": "src/api/users.ts",
      "line_start": 42,
      "line_end": 45,
      "vulnerability_type": "SQL Injection",
      "description": "User input from req.params.id is directly interpolated into SQL query without parameterization.",
      "code_snippet": "const result = await db.query(`SELECT * FROM users WHERE id = '${userId}'`);",
      "remediation": "Use parameterized queries: db.query('SELECT * FROM users WHERE id = $1', [userId])",
      "confidence": "verified",
      "cvss": 9.8,
      "data_flow": {
        "source": "req.params.id",
        "sink": "db.query()",
        "tainted_path": ["req.params.id", "userId", "db.query()"]
      }
    }
  ]
}
```

**IMPORTANT**:
1. Generate this JSON file using the Write tool AFTER generating the markdown report
2. Use consistent severity values: "critical", "high", "medium", "low", "info"
3. Use consistent confidence values: "verified", "high", "medium", "low"
4. Include CWE IDs where applicable
5. The `findings` array should contain ALL findings from the audit

**Bash command to validate JSON output:**
```bash
# Verify JSON is valid
python3 -c "import json; json.load(open('.claude/findings.json'))" && echo "✓ Valid JSON"
```

---

## Execution Flow

### Setup Phase

```bash
# Create output directory
mkdir -p .claude

# Check prerequisites
npx repomix --version  # Required for scoping
```

### Progress Display

```
╔═══════════════════════════════════════════════════════════════╗
║                    FULL AUDIT IN PROGRESS                      ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                ║
║  [✓] Step 0: Size check                                       ║
║      → 1.68M tokens detected                                   ║
║      → Strategy: Architecture-First                            ║
║                                                                ║
║  [✓] Step 1: Architecture scope                               ║
║      → Language: Go                                            ║
║      → Compressed: 1.68M → 47k tokens (97% reduction)         ║
║                                                                ║
║  [✓] Step 2: Threat modeling                                  ║
║      → Components: 24                                          ║
║      → Trust boundaries: 5                                     ║
║      → Threats: 3 CRITICAL, 5 HIGH                            ║
║                                                                ║
║  [✓] Step 3: Module identification                            ║
║      → Modules ranked: 8                                       ║
║      → Selected for audit: 3                                   ║
║                                                                ║
║  [▸] Step 4: Deep dive audit                                  ║
║      → query-service (1/3)...                                  ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝
```

### Completion Summary

```
╔═══════════════════════════════════════════════════════════════╗
║                    AUDIT COMPLETE                              ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                ║
║  Target: /path/to/code                                         ║
║  Size: 1.68M tokens → 47k architecture + 3 module scopes      ║
║  Duration: 4m 32s                                              ║
║                                                                ║
║  Findings:                                                     ║
║  ├── CRITICAL: 3                                              ║
║  ├── HIGH:     5                                              ║
║  ├── MEDIUM:   8                                              ║
║  └── LOW:      4                                              ║
║                                                                ║
║  Output Files:                                                 ║
║  ├── .claude/scope-architecture.md (47k tokens)               ║
║  ├── .claude/threat-model.md                                  ║
║  ├── .claude/scope-query-service.md                           ║
║  ├── .claude/scope-index-service.md                           ║
║  ├── .claude/scope-data-export.md                             ║
║  └── .claude/audit-report.md                                  ║
║                                                                ║
║  Top Issues:                                                   ║
║  1. Query Injection (query-service/svc/service.go:142)        ║
║  2. Filter Bypass (query-service/interfaces/data_selector.go) ║
║  3. Secret Exposure (services/data-export/common/)            ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## Quick Mode (--quick)

Skip threat modeling for faster results:

```
/whitebox-pentest:full-audit /path/to/code --quick
```

**Quick mode**:
- ✓ Step 0: Size check
- ✓ Step 1: Architecture scope (if needed)
- ✗ Step 2: Threat model (skipped)
- ✓ Step 3: Module identification (uses file patterns instead)
- ✓ Step 4: Deep dive audit
- ✓ Step 5: Report

**Use when**: You need fast results and will do detailed threat modeling later.

---

## Polyglot Workflow (Automatic)

When a mixed-language monorepo is detected, the workflow automatically adapts:

```
┌─────────────────────────────────────────────────────────────┐
│                 POLYGLOT AUDIT PIPELINE                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Step 0: POLYGLOT DETECTION                                 │
│  └─> Count languages, map services, detect protocols        │
│                                                              │
│  Step 1: SERVICE DISCOVERY                                   │
│  └─> Map services → languages → communication protocols     │
│                                                              │
│  Step 2: CROSS-SERVICE ARCHITECTURE SCOPE                   │
│  └─> Lightweight scope of all services + protocol defs      │
│                                                              │
│  Step 3: CROSS-SERVICE THREAT MODEL                         │
│  └─> Trust boundaries between services, data flows          │
│                                                              │
│  Step 4: PER-SERVICE DEEP DIVE (by priority)                │
│  └─> Each service scoped with its language strategy         │
│  └─> Language-specific sinks applied                        │
│                                                              │
│  Step 5: CROSS-SERVICE VERIFICATION                         │
│  └─> Verify data flows across service boundaries            │
│  └─> Check auth token propagation, schema validation        │
│                                                              │
│  Step 6: UNIFIED REPORT                                      │
│  └─> All findings + cross-service issues                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### Polyglot Step 1: Service Discovery

```bash
# Generate service inventory
echo "=== Service Discovery ==="

# Go services
for f in $(find [path] -name 'main.go' 2>/dev/null); do
  dir=$(dirname "$f")
  tokens=$(npx repomix "$dir" --style markdown -o /dev/null 2>&1 | grep "Total Tokens" | awk '{print $3}')
  echo "Go: $dir ($tokens tokens)"
done

# Python services
for f in $(find [path] \( -name 'main.py' -o -name 'app.py' -o -name 'manage.py' \) 2>/dev/null); do
  dir=$(dirname "$f")
  tokens=$(npx repomix "$dir" --style markdown -o /dev/null 2>&1 | grep "Total Tokens" | awk '{print $3}')
  echo "Python: $dir ($tokens tokens)"
done

# TypeScript/Node services
for f in $(find [path] -name 'package.json' ! -path '*/node_modules/*' 2>/dev/null); do
  dir=$(dirname "$f")
  if grep -q '"start"' "$f" 2>/dev/null; then
    tokens=$(npx repomix "$dir" --style markdown -o /dev/null 2>&1 | grep "Total Tokens" | awk '{print $3}')
    echo "TypeScript/JS: $dir ($tokens tokens)"
  fi
done
```

### Polyglot Step 2: Cross-Service Architecture Scope

Create a lightweight architecture-only scope capturing all services:

```bash
npx repomix [path] --compress --style markdown \
  --include "**/proto/**/*.proto,**/openapi*.yaml,**/swagger*.yaml,**/*.graphql,**/docker-compose*.yml,**/Dockerfile*,**/main.go,**/main.py,**/app.py,**/index.ts,**/*Application.java,**/Cargo.toml,**/go.mod,**/package.json,**/requirements.txt,**/pyproject.toml" \
  --ignore "**/node_modules/**,**/vendor/**,**/target/**,**/.venv/**,**/dist/**,**/build/**,**/__pycache__/**" \
  --output .claude/scope-architecture-polyglot.md
```

### Polyglot Step 3: Cross-Service Threat Model

When threat modeling polyglot systems, focus on:

1. **Service Boundaries as Trust Boundaries**
   - Every service-to-service call is a potential trust boundary
   - Auth tokens must be validated at each hop

2. **Protocol-Specific Threats**
   | Protocol | Threats |
   |----------|---------|
   | gRPC | No auth interceptor, reflection exposed, large message DoS |
   | REST | CORS misconfiguration, header injection, missing HTTPS |
   | Kafka | Unauthenticated broker, message injection, poison message |
   | GraphQL | Query depth attack, introspection exposure, batching abuse |

3. **Data Flow Diagram (Cross-Service)**
   ```mermaid
   graph TB
       subgraph External
           User[User]
       end
       subgraph Gateway[API Gateway - Go]
           Auth[Auth Middleware]
           Router[Router]
       end
       subgraph Services
           AuthSvc[Auth Service - Go]
           MLSvc[ML Service - Python]
           DataSvc[Data Service - Java]
       end
       subgraph Data
           DB[(PostgreSQL)]
           Queue[Kafka]
       end

       User -->|HTTPS| Auth
       Auth --> Router
       Router -->|gRPC| AuthSvc
       Router -->|REST| MLSvc
       MLSvc -->|Kafka| Queue
       Queue --> DataSvc
       DataSvc -->|SQL| DB
   ```

### Polyglot Step 4: Per-Service Deep Dive

For each service in priority order:

1. **Create language-specific scope:**
   ```bash
   # Go service
   npx repomix services/auth --compress --style markdown \
     --include "**/interfaces/**/*.go,**/handler/**/*.go,**/svc/**/*.go" \
     --ignore "*_test.go,**/*.pb.go" \
     --output .claude/scope-auth.md

   # Python service
   npx repomix services/ml --compress --style markdown \
     --include "**/api/**/*.py,**/routes/**/*.py,**/models/**/*.py,**/schemas/**/*.py" \
     --ignore "**/*_test.py,**/tests/**" \
     --output .claude/scope-ml.md
   ```

2. **Apply language-specific sinks** (see `dangerous-functions` skill):
   - Go sinks: os/exec, database/sql, html/template
   - Python sinks: eval, subprocess, raw SQL, deserialization
   - Java sinks: Runtime, JDBC, serialization
   - TypeScript sinks: eval, child_process, DOM APIs

3. **Trace cross-service data flows:**
   - Input enters at Gateway → Where does it flow?
   - Which services handle user-controlled data?
   - Where are sanitization/validation points?

### Polyglot Step 5: Cross-Service Verification

Check common cross-service vulnerabilities:

1. **Auth Token Propagation**
   ```bash
   # Find how auth is passed between services
   grep -rniE "X-User-ID|X-Auth|Authorization|Bearer" --include="*.go" --include="*.py" --include="*.java" --include="*.ts"
   ```

2. **Input Validation Gaps**
   ```bash
   # Find services that trust upstream validation
   grep -rniE "validated upstream|validated by gateway|trusted input" --include="*.go" --include="*.py" --include="*.java"
   ```

3. **Error Message Leakage**
   ```bash
   # Find error pass-through patterns
   grep -rniE "err\.Error\(\)|str\(e\)|e\.getMessage\(\)" --include="*.go" --include="*.py" --include="*.java"
   ```

4. **Schema Mismatches**
   ```bash
   # Compare proto versions across services
   diff <(grep "message\|field" services/auth/proto/*.proto) <(grep "message\|field" services/ml/proto/*.proto)
   ```

### Polyglot Progress Display

```
╔═══════════════════════════════════════════════════════════════╗
║                 POLYGLOT AUDIT IN PROGRESS                    ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                ║
║  [✓] Step 0: Polyglot detection                              ║
║      → Languages: Go (450), Python (380), TypeScript (420)    ║
║      → Services: 5 detected                                   ║
║                                                                ║
║  [✓] Step 1: Service discovery                               ║
║      → api-gateway (Go, 85k tokens, HIGH)                    ║
║      → auth-service (Go, 45k tokens, CRITICAL)               ║
║      → ml-pipeline (Python, 120k tokens, HIGH)               ║
║      → web-frontend (TypeScript, 200k tokens, MEDIUM)        ║
║      → data-processor (Java, 90k tokens, MEDIUM)             ║
║                                                                ║
║  [✓] Step 2: Cross-service architecture scope                ║
║      → Protocol defs: 15 proto, 2 OpenAPI                    ║
║      → Scope: .claude/scope-architecture-polyglot.md         ║
║                                                                ║
║  [✓] Step 3: Cross-service threat model                      ║
║      → Trust boundaries: 6                                    ║
║      → Cross-service threats: 4 HIGH                         ║
║                                                                ║
║  [▸] Step 4: Per-service deep dive                           ║
║      → auth-service (1/5): 2 CRITICAL findings               ║
║      → api-gateway (2/5): in progress...                     ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝
```

### Polyglot Completion Summary

```
╔═══════════════════════════════════════════════════════════════╗
║                 POLYGLOT AUDIT COMPLETE                       ║
╠═══════════════════════════════════════════════════════════════╣
║                                                                ║
║  Target: /path/to/polyglot-monorepo                           ║
║  Languages: Go, Python, TypeScript, Java                      ║
║  Services audited: 5                                          ║
║                                                                ║
║  Findings by Service:                                         ║
║  ├── auth-service (Go): 2 CRITICAL, 1 HIGH                   ║
║  ├── api-gateway (Go): 1 HIGH, 2 MEDIUM                      ║
║  ├── ml-pipeline (Python): 1 CRITICAL, 2 HIGH                ║
║  ├── web-frontend (TypeScript): 3 MEDIUM                     ║
║  └── data-processor (Java): 1 HIGH                           ║
║                                                                ║
║  Cross-Service Findings:                                      ║
║  ├── Auth token not validated in ml-pipeline (CRITICAL)      ║
║  ├── Error messages leak from Python to Gateway (MEDIUM)     ║
║  └── No mTLS between gateway and auth-service (HIGH)         ║
║                                                                ║
║  Output Files:                                                 ║
║  ├── .claude/scope-architecture-polyglot.md                  ║
║  ├── .claude/threat-model-polyglot.md                        ║
║  ├── .claude/scope-auth.md                                   ║
║  ├── .claude/scope-gateway.md                                ║
║  ├── .claude/scope-ml.md                                     ║
║  ├── .claude/scope-web.md                                    ║
║  ├── .claude/scope-processor.md                              ║
║  └── .claude/audit-report-polyglot.md                        ║
║                                                                ║
╚═══════════════════════════════════════════════════════════════╝
```

---

## Prerequisites

### Required
- **repomix**: Codebase scoping and token counting
  ```bash
  npm install -g repomix
  ```

### Recommended
- **Semgrep**: Fast pattern matching (auto-used if available)
  ```bash
  pip install semgrep
  ```

- **Joern**: CPG analysis for verification
  ```bash
  curl -L "https://github.com/joernio/joern/releases/latest/download/joern-install.sh" | bash
  ```

### For Solidity/Smart Contracts
- **Slither**: Fast Solidity static analysis
  ```bash
  pip install slither-analyzer
  ```

---

## Integration with CI/CD

### GitHub Action Example

```yaml
name: Security Audit
on: [pull_request]

jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          pip install semgrep
          curl -L ".../joern-install.sh" | bash

      - name: Run full audit
        run: |
          claude-code "/whitebox-pentest:full-audit . --quick"

      - name: Check for critical findings
        run: |
          if grep -q "CRITICAL.*VERIFIED" .claude/security-report.md; then
            echo "Critical vulnerabilities found!"
            exit 1
          fi

      - name: Upload report
        uses: actions/upload-artifact@v3
        with:
          name: security-report
          path: .claude/
```

---

## Customization

### Focus on Specific Vulnerability Types

```
/whitebox-pentest:full-audit . --focus sql-injection,command-injection
```

### Exclude Directories

```
/whitebox-pentest:full-audit . --exclude node_modules,vendor,test
```

### Set Severity Threshold

```
/whitebox-pentest:full-audit . --min-severity high
```

---

## Examples

### Audit a Go monorepo
```bash
/whitebox-pentest:full-audit ~/code/my-go-project
# Auto-detects Go, uses directory-based compression
# 1.68M tokens → 47k architecture scope (97% reduction)
```

### Audit a TypeScript project
```bash
/whitebox-pentest:full-audit ~/code/my-app
# Auto-detects TS, uses Tree-sitter compression
# ~80% token reduction
```

### Audit with more modules
```bash
/whitebox-pentest:full-audit --top 5
# Audits top 5 riskiest modules instead of default 3
```

### Audit a polyglot monorepo (Go + Python + TypeScript)
```bash
/whitebox-pentest:full-audit ~/code/platform
# Automatically detects mixed-language codebase
# Scopes each service with language-appropriate compression
# Generates cross-service threat model
# Audits services in priority order (auth first, then APIs, then ML)
```

### Force single-language mode (skip polyglot detection)
```bash
/whitebox-pentest:full-audit ~/code/platform --language go
# Forces Go-specific analysis only
# Useful when you want to focus on just one language/service type
```

---

## Notes

- **Large codebases**: Automatically handled via architecture-first workflow
- **Language detection**: Auto-detects Go, TS/JS, Python, Java, Rust, PHP, C#, Ruby, Solidity
- **Polyglot support**: Automatically detects mixed-language monorepos, scopes each service appropriately
- **Compression rates**: Go achieves 95-97%, TS/JS achieves ~80%, Python 85-90%
- **Cross-service security**: Analyzes trust boundaries, auth propagation, protocol-specific threats
- **Duration**: 2-5 minutes for single-language, 5-15 minutes for polyglot codebases
- **Artifacts cached**: Re-run is faster if `.claude/` artifacts exist
- Use `--quick` for faster iteration (skips threat modeling)
- Use `--language` to force single-language mode and skip polyglot detection
- All outputs saved to `.claude/` directory
- Add `.claude/` to `.gitignore` if desired

---

## Agent Integration

The full-audit pipeline can leverage specialized agents for deeper analysis:

### Code Reviewer Agent

For detailed vulnerability hunting in high-risk modules:

```
Use Task tool with:
  subagent_type: "whitebox-pentest:code-reviewer"
  prompt: |
    Review this module for security vulnerabilities:
    - Module: [module_path]
    - Focus areas: [from threat model]
    - Previous findings: [list any known issues]
```

### Local Tester Agent

For dynamic testing guidance after vulnerabilities are found:

```
Use Task tool with:
  subagent_type: "whitebox-pentest:local-tester"
  prompt: |
    Guide dynamic testing for:
    - Finding: [vulnerability description]
    - Location: [file:line]
    - Application setup: [how to run locally]
```

### PoC Developer Agent

**IMPORTANT**: PoC development should only occur after manual verification of the exploit chain. The audit report provides vulnerability building blocks, not ready-to-use exploits.

```
Use Task tool with:
  subagent_type: "whitebox-pentest:poc-developer"
  prompt: |
    Develop PoC for:
    - Vulnerability: [type and description]
    - Target: [endpoint/function]
    - Constraints: [environment limitations]
    - Verified: [YES - describe how chain was verified]
```

### Patch Advisor Agent

For remediation recommendations:

```
Use Task tool with:
  subagent_type: "whitebox-pentest:patch-advisor"
  prompt: |
    Recommend fixes for:
    - Finding: [vulnerability]
    - Code context: [relevant code snippet]
    - Framework: [language/framework in use]
```

These agents run autonomously and integrate with the main audit workflow.

---

## Exploit Chain Verification Checklist

**IMPORTANT**: The audit report identifies vulnerability building blocks, not verified exploit chains. Before considering an exploit chain viable, verify each component:

### SSRF-Based Attacks

- [ ] Can the SSRF target external URLs? (Check `base_url` prefix restrictions)
- [ ] Is the response returned to the attacker? (Direct vs blind SSRF)
- [ ] Is there a proxy cache that could store the response?
- [ ] What file extensions trigger caching? (Check nginx/proxy config)
- [ ] Is DNS exfiltration possible? (Network restrictions)

### Cache-Based Exfiltration

- [ ] What paths are cached? (Check proxy config)
- [ ] How is cache key constructed? (Extension, path, headers?)
- [ ] Does the application serve dynamic content regardless of extension?
- [ ] What is the cache TTL? (Time window for attack)
- [ ] Are authenticated responses cacheable? (Check Vary header)

### Cross-Layer Attacks

- [ ] Does the application layer behavior align with proxy layer assumptions?
- [ ] Are there path normalization differences between layers?
- [ ] Do error responses get cached differently than success responses?

### General Verification

- [ ] Run locally with Docker/test environment first
- [ ] Confirm each step of the chain independently
- [ ] Verify network restrictions don't block the attack
- [ ] Check for rate limiting or WAF that could block exploitation

**Note**: The audit report should describe vulnerability connections without providing ready-to-use exploit code. Analysts should verify chains before developing PoCs.

---

## ⚠️ MANDATORY FINAL STEP: JSON OUTPUT ⚠️

**CRITICAL**: After completing the audit and generating `.claude/audit-report.md`, you MUST ALSO generate a machine-readable JSON findings file. This is REQUIRED for integration with security dashboards and CI/CD pipelines.

### Required Action

Use the Write tool to create `.claude/findings.json` with this EXACT structure:

```json
{
  "scan_id": "<generate-uuid>",
  "project_path": "<target-path>",
  "completed_at": "<ISO-8601-timestamp>",
  "summary": {
    "total": <number>,
    "critical": <number>,
    "high": <number>,
    "medium": <number>,
    "low": <number>,
    "info": <number>
  },
  "findings": [
    {
      "id": "VULN-001",
      "title": "<finding-title>",
      "severity": "critical|high|medium|low|info",
      "cwe_id": "CWE-<number>",
      "file_path": "<relative-path>",
      "line_start": <line-number>,
      "vulnerability_type": "<type>",
      "description": "<description>",
      "remediation": "<fix-recommendation>",
      "confidence": "verified|high|medium|low"
    }
  ]
}
```

### Checklist Before Completing Audit

- [ ] Generated `.claude/audit-report.md` (markdown report)
- [ ] Generated `.claude/findings.json` (JSON for automation)
- [ ] Verified JSON is valid: `python3 -c "import json; json.load(open('.claude/findings.json'))"`

**DO NOT mark the audit as complete until BOTH files are generated.**
