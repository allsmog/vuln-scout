---
name: ssrf-chains
description: SSRF as a pivot point for chained attacks, including internal service exploitation and cloud metadata access.
---

# SSRF Chain Patterns

SSRF (Server-Side Request Forgery) is often the first step in a chain. It enables reaching services that are otherwise inaccessible.

## SSRF Sources

### Framework-Specific

| Framework | SSRF Pattern |
|-----------|--------------|
| Next.js | Server Action redirect() with Host header control |
| React SSR | Server-side fetch with user URL |
| Flask | requests.get() with user URL |
| PHP | file_get_contents(), curl with user URL |
| Java | URL.openConnection(), HttpClient with user URL |

### Common Patterns

```bash
# Find potential SSRF sources
grep -rn "fetch\|requests\.\|curl\|http\.get\|HttpClient" --include="*.ts" --include="*.py" --include="*.java" --include="*.php"

# Check for user input in URL
grep -rn "request\.\|req\.\|\$_GET\|\$_POST" -A 5 | grep -E "fetch|requests|curl"
```

## What SSRF Can Reach

### 1. Internal Web Services

**Detection:**
```bash
# Find internal service definitions
grep -rE "localhost:|127\.0\.0\.1:|0\.0\.0\.0:" docker-compose.yml supervisord.conf
grep -rE "INTERNAL_.*URL|SERVICE_.*HOST" --include="*.env*"
```

**Common targets:**
- Admin panels on non-exposed ports
- Internal APIs without auth
- Development/debug endpoints

### 2. Cloud Metadata Endpoints

| Cloud | Endpoint |
|-------|----------|
| AWS | `http://169.254.169.254/latest/meta-data/` |
| GCP | `http://metadata.google.internal/computeMetadata/v1/` |
| Azure | `http://169.254.169.254/metadata/instance` |
| DigitalOcean | `http://169.254.169.254/metadata/v1/` |

**Detection:**
```bash
# Check if IMDSv2 is enforced (AWS)
grep -rn "HttpPutResponseHopLimit\|http-tokens" --include="*.tf" --include="*.yaml"
```

### 3. Internal Databases

| Database | Protocol |
|----------|----------|
| Redis | `redis://localhost:6379` |
| Memcached | `memcached://localhost:11211` |
| Elasticsearch | `http://localhost:9200` |
| MongoDB | `mongodb://localhost:27017` |

### 4. Container/Orchestration APIs

| Service | Endpoint |
|---------|----------|
| Docker | `http://localhost:2375` |
| Kubernetes | `https://kubernetes.default.svc` |
| Consul | `http://localhost:8500` |

## SSRF → SSTI Chain (DoxPit Pattern)

### Prerequisites
1. SSRF in externally-accessible service
2. SSTI in internal service
3. SSRF can reach SSTI endpoint with controlled input

### Detection Workflow

```bash
# Step 1: Find SSRF sources
grep -rn "redirect\(" --include="*.ts" --include="*.tsx" | grep -v node_modules

# Step 2: Find internal services
cat supervisord.conf docker-compose.yml 2>/dev/null | grep -E "port|command"

# Step 3: Find SSTI sinks in internal services
grep -rn "render_template_string\|Template\(" --include="*.py"

# Step 4: Check if SSRF can reach SSTI
# - SSRF on port 1337, SSTI on port 3000
# - Both in same container/network? → Chain possible
```

### Example Chain

```
1. Next.js frontend (port 1337, external)
   - Server Action with redirect("/error")
   - Attacker sets Host: attacker.com

2. Attacker's server
   - Returns 302 redirect to http://127.0.0.1:3000/home?directory=SSTI_PAYLOAD

3. Flask backend (port 3000, internal only)
   - /home endpoint uses render_template_string()
   - directory parameter reaches template → SSTI → RCE
```

## SSRF → Cloud Metadata Chain

### Prerequisites
1. SSRF capability
2. App running in cloud environment
3. No IMDSv2 or metadata blocking

### Detection Workflow

```bash
# Check for cloud deployment
find . -name "*.tf" -o -name "cloudformation*.yaml" -o -name "*.bicep"

# Check Dockerfile for cloud SDK
grep -rn "aws-sdk\|google-cloud\|azure" package.json requirements.txt

# Check for metadata protection
grep -rn "169\.254\.169\.254" --include="*.yaml" --include="*.tf"
```

### Exploitation Impact

| Metadata | Impact |
|----------|--------|
| IAM credentials | AWS/GCP/Azure API access |
| User data | May contain secrets, startup scripts |
| Network config | Internal IP ranges, VPC info |
| Instance identity | Token for further API calls |

## SSRF → Internal Admin Chain

### Prerequisites
1. SSRF capability
2. Admin panel on internal port
3. No auth on internal requests (common!)

### Detection Workflow

```bash
# Find admin routes
grep -rn "admin\|dashboard\|internal" --include="*.py" --include="*.ts" | grep -E "route|path|endpoint"

# Check for internal-only auth skip
grep -rn "if.*localhost\|if.*127\.0\.0\.1\|X-Forwarded-For" --include="*.py" --include="*.ts"
```

## Mitigation Verification

Check if SSRF is mitigated:

```bash
# URL allowlist
grep -rn "ALLOWED_HOSTS\|ALLOWED_URLS\|whitelist" --include="*.py" --include="*.ts"

# DNS rebinding protection
grep -rn "resolve\|dns\|getaddrinfo" --include="*.py" --include="*.ts"

# Private IP blocking
grep -rn "is_private\|isPrivate\|169\.254\|10\.\|192\.168\|172\." --include="*.py" --include="*.ts"
```

## Chain Reporting Template

```markdown
## SSRF Chain: [Source] → [Target]

**Severity:** CRITICAL

**SSRF Source:**
- Location: [file:line]
- Type: [redirect/fetch/curl/etc.]
- Control: [Full URL / Path only / Host header]

**Target Service:**
- Service: [name]
- Port: [internal port]
- Vulnerability: [SSTI/SQLi/RCE/etc.]

**Chain Flow:**
1. Attacker sends request with [controlled element]
2. Server makes request to [target]
3. Target processes [payload] → [impact]

**Proof of Concept:** [Description, not full exploit]
```
