# Reentrancy Vulnerability Patterns in Solidity

Reentrancy is a critical vulnerability where an external call allows the called contract to re-enter the calling function before state updates are complete. This document covers detection patterns, exploitation techniques, and secure coding practices.

---

## TL;DR - The Key Pattern

**VULNERABLE (External Call Before State Change):**
```solidity
function withdraw(uint amount) external {
    require(balances[msg.sender] >= amount);
    (bool success, ) = msg.sender.call{value: amount}("");  // EXTERNAL CALL
    require(success);
    balances[msg.sender] -= amount;  // STATE CHANGE - TOO LATE!
}
```

**SAFE (CEI Pattern - Checks-Effects-Interactions):**
```solidity
function withdraw(uint amount) external {
    require(balances[msg.sender] >= amount);  // CHECK
    balances[msg.sender] -= amount;           // EFFECT (state change FIRST)
    (bool success, ) = msg.sender.call{value: amount}("");  // INTERACTION (last)
    require(success);
}
```

---

## Vulnerability Categories

### 1. Classic ETH Reentrancy (CWE-841)

The most common pattern - draining ETH via recursive calls.

**Vulnerable Pattern:**
```solidity
function withdraw() external {
    uint256 amount = balances[msg.sender];
    (bool success, ) = msg.sender.call{value: amount}("");  // Attacker's receive() reenters
    require(success);
    balances[msg.sender] = 0;  // Never reached during attack
}
```

**Attack Contract:**
```solidity
contract Attacker {
    Victim victim;

    function attack() external payable {
        victim.deposit{value: 1 ether}();
        victim.withdraw();  // Start the drain
    }

    receive() external payable {
        if (address(victim).balance >= 1 ether) {
            victim.withdraw();  // Reenter before balance updated
        }
    }
}
```

**Detection Pattern (grep):**
```bash
# Find external calls followed by state changes
rg -U "\.call\{value:[^}]*\}[^;]*;[^}]*(balances|amount|balance)\s*(-=|=)" --glob="*.sol"

# Find .call without CEI pattern
grep -rn "\.call{value:" --include="*.sol" -A 5 | grep -E "(\-=|=.*0)"
```

---

### 2. Cross-Function Reentrancy

Attack reenters a DIFFERENT function that reads stale state.

**Vulnerable Pattern:**
```solidity
contract Vault {
    mapping(address => uint) public balances;

    function withdraw() external {
        uint amount = balances[msg.sender];
        (bool success, ) = msg.sender.call{value: amount}("");
        // Attacker calls transfer() here before balance updated
        balances[msg.sender] = 0;
    }

    function transfer(address to, uint amount) external {
        require(balances[msg.sender] >= amount);  // Uses stale balance!
        balances[msg.sender] -= amount;
        balances[to] += amount;
    }
}
```

**Detection Pattern:**
```bash
# Find contracts with multiple functions accessing same state variable
grep -rn "balances\[msg.sender\]" --include="*.sol" | cut -d: -f1 | uniq -c | awk '$1 > 1'
```

---

### 3. Read-Only Reentrancy

Exploits view functions that return stale state during reentrancy.

**Vulnerable Pattern:**
```solidity
contract LendingPool {
    function getCollateralValue(address user) public view returns (uint) {
        return balances[user] * getPrice();  // Returns stale value during withdraw
    }

    function withdraw(uint amount) external {
        require(getCollateralValue(msg.sender) >= minCollateral);
        (bool success, ) = msg.sender.call{value: amount}("");  // Reenter here
        balances[msg.sender] -= amount;  // Balance not yet updated
    }

    function borrow(uint amount) external {
        require(getCollateralValue(msg.sender) >= amount);  // Uses stale collateral!
        // Attacker borrows against phantom collateral
    }
}
```

**Detection Pattern:**
```bash
# Find view functions called in same contract with external calls
grep -rn "function.*view.*returns" --include="*.sol" -B 2 -A 10
```

---

### 4. ERC Token Callback Reentrancy

**ERC-721 safeTransferFrom:**
```solidity
// Vulnerable - onERC721Received is called before state update
function claimNFT(uint tokenId) external {
    require(claims[tokenId] == msg.sender);
    nft.safeTransferFrom(address(this), msg.sender, tokenId);  // Callback here!
    delete claims[tokenId];  // Too late
}
```

**ERC-777 tokensReceived:**
```solidity
// Vulnerable - ERC777 calls tokensReceived hook
function deposit(uint amount) external {
    token.transferFrom(msg.sender, address(this), amount);  // Hook fires!
    balances[msg.sender] += amount;  // Attacker already called withdraw()
}
```

**ERC-1155 onERC1155Received:**
```solidity
// Vulnerable - safeTransferFrom triggers receiver hook
function withdraw(uint id, uint amount) external {
    require(balances[msg.sender][id] >= amount);
    token.safeTransferFrom(address(this), msg.sender, id, amount, "");  // Hook!
    balances[msg.sender][id] -= amount;  // Too late
}
```

**Detection Pattern:**
```bash
# Find safe transfer patterns (potential callback reentrancy)
grep -rn "safeTransfer\|safeMint\|_safeMint" --include="*.sol"

# Find ERC777 usage
grep -rn "IERC777\|tokensReceived\|tokensToSend" --include="*.sol"

# Find ERC1155 callbacks
grep -rn "onERC1155Received\|onERC1155BatchReceived" --include="*.sol"
```

---

### 5. Delegatecall Reentrancy

Storage slot collision in proxy patterns.

**Vulnerable Pattern:**
```solidity
contract Proxy {
    address public implementation;  // Slot 0

    fallback() external payable {
        (bool success, ) = implementation.delegatecall(msg.data);
        require(success);
    }
}

contract MaliciousImpl {
    address public owner;  // Also slot 0 - COLLISION!

    function attack() external {
        owner = msg.sender;  // Overwrites Proxy.implementation!
    }
}
```

---

## Detection Checklist

### Manual Review Steps

1. **Find all external calls:**
   ```bash
   grep -rniE "\.call\{value:|\.call\(|\.delegatecall\(|\.send\(|\.transfer\(" --include="*.sol"
   ```

2. **Check for state changes AFTER each external call:**
   - Assignment operators: `=`, `-=`, `+=`
   - `delete` statements
   - Array operations: `.push()`, `.pop()`
   - Mapping updates

3. **Verify reentrancy guards exist:**
   ```bash
   grep -rniE "nonReentrant|ReentrancyGuard|mutex|locked" --include="*.sol"
   ```

4. **Check for token callbacks:**
   ```bash
   grep -rniE "safeTransfer|safeMint|IERC777|onERC" --include="*.sol"
   ```

5. **Review view functions called during transactions:**
   - Can they return stale data during reentrancy?
   - Are they used for access control or value calculations?

---

## Secure Patterns

### 1. Checks-Effects-Interactions (CEI)

```solidity
function withdraw(uint amount) external {
    // CHECKS
    require(balances[msg.sender] >= amount, "Insufficient balance");
    require(amount > 0, "Zero amount");

    // EFFECTS (all state changes)
    balances[msg.sender] -= amount;
    totalDeposits -= amount;

    // INTERACTIONS (external calls last)
    (bool success, ) = msg.sender.call{value: amount}("");
    require(success, "Transfer failed");
}
```

### 2. Reentrancy Guard (OpenZeppelin)

```solidity
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

contract Vault is ReentrancyGuard {
    function withdraw(uint amount) external nonReentrant {
        require(balances[msg.sender] >= amount);
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
        balances[msg.sender] -= amount;  // Now safe even if after call
    }
}
```

### 3. Pull Payment Pattern

```solidity
contract PullPayment {
    mapping(address => uint) public pendingWithdrawals;

    function _asyncTransfer(address dest, uint amount) internal {
        pendingWithdrawals[dest] += amount;  // No external call
    }

    function withdrawPayment() external {
        uint amount = pendingWithdrawals[msg.sender];
        pendingWithdrawals[msg.sender] = 0;  // Effect before interaction
        (bool success, ) = msg.sender.call{value: amount}("");
        require(success);
    }
}
```

### 4. Mutex Lock (Manual)

```solidity
contract Vault {
    bool private locked;

    modifier noReentrant() {
        require(!locked, "Reentrant call");
        locked = true;
        _;
        locked = false;
    }

    function withdraw(uint amount) external noReentrant {
        // Safe from reentrancy
    }
}
```

---

## CTF/Audit Quick Reference

### Exploitation Steps

1. **Identify the sink:** Find `.call{value:}` or token transfers
2. **Trace state changes:** What happens after the external call?
3. **Check guards:** Is there `nonReentrant` or CEI pattern?
4. **Build attack contract:**
   - Implement `receive()` or `fallback()` for ETH
   - Implement token hooks for ERC721/777/1155
5. **Calculate attack economics:** Can you profit after gas?

### Common Mistake Patterns

| Pattern | Why It's Vulnerable |
|---------|---------------------|
| `call{value:}` then `delete` | Classic reentrancy - delete happens after callback |
| `call{value:}` then `-=` | Balance not updated before reentry |
| `safeTransferFrom` then state update | Token hook fires before update |
| View function in `require` | Returns stale data during reentrancy |
| Multiple functions share state | Cross-function reentrancy possible |

---

## Integration with Scanner

### Joern CPG Verification

```bash
# Verify specific finding
joern --script verify-reentrancy.sc \
  --params cpgFile=contracts.cpg,file=Vault.sol,line=45
```

### Slither Detection

```bash
# Run reentrancy detectors
slither . --detect reentrancy-eth,reentrancy-no-eth,reentrancy-benign
```

### Mythril Symbolic Execution

```bash
# Deep analysis for complex reentrancy paths
myth analyze contracts/Vault.sol --execution-timeout 300
```

---

## References

- [SWC-107: Reentrancy](https://swcregistry.io/docs/SWC-107)
- [CWE-841: Improper Enforcement of Behavioral Workflow](https://cwe.mitre.org/data/definitions/841.html)
- [The DAO Hack (2016)](https://blog.openzeppelin.com/15-lines-of-code-that-could-have-prevented-thedao-hack)
- [OpenZeppelin ReentrancyGuard](https://docs.openzeppelin.com/contracts/4.x/api/security#ReentrancyGuard)
