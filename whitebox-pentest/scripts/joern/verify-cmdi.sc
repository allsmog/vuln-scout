// Command Injection Verification Script
// Verifies if user input reaches shell execution functions
//
// Usage: joern --script verify-cmdi.sc --params cpgFile=app.cpg,file=backup.ts,line=42

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int) = {
  importCpg(cpgFile)

  println(s"[*] Verifying command injection at $file:$line")

  // Command execution sinks
  val cmdSinkPattern = "execSync|spawnSync|execFile|system|popen|child_process"

  // Find the target sink
  val targetSinks = cpg.call.name(cmdSinkPattern)
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.lineNumber.getOrElse(0) == line)
    .l

  if (targetSinks.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.0,
      reason = s"No command execution sink found at $file:$line"
    ))
    return
  }

  val sink = targetSinks.head

  // Define sources (user input)
  val sources = cpg.parameter.name(".*req.*|.*request.*|.*body.*|.*params.*|.*query.*")

  // Check if any source reaches this sink
  val flows = sink.argument.reachableBy(sources).l

  if (flows.isEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "No data flow from user input to command execution"
    ))
    return
  }

  // Check for spawn with array arguments (safe pattern)
  val isSpawnWithArray = sink.name == "spawn" && {
    sink.argument.l.size > 1 &&
    sink.argument(2).isArrayInitializer.l.nonEmpty
  }

  if (isSpawnWithArray) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.90,
      reason = "spawn() called with array arguments - arguments are not shell-interpreted"
    ))
    return
  }

  // Check for type coercion to number
  val typeCoerced = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("parseInt|parseFloat|Number|toInt"))
    .l

  if (typeCoerced.size == flows.size && typeCoerced.nonEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "Input is type-coerced to number - cannot inject shell commands"
    ))
    return
  }

  // Check for allowlist validation
  val hasAllowlist = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("includes|indexOf|allowlist|whitelist|match"))
    .l

  if (hasAllowlist.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.50,
      reason = "Possible allowlist validation detected - verify allowlist is restrictive"
    ))
    return
  }

  // Check for shell metacharacter escaping
  val hasEscaping = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("escape|quote|shellescape"))
    .l

  if (hasEscaping.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.60,
      reason = "Shell escaping function detected - verify escaping is complete"
    ))
    return
  }

  // Build data flow path
  val flowPath = sink.argument.reachableByFlows(sources).l.headOption.map { flow =>
    val elements = flow.elements.l
    DataFlowPath(
      sourceFile = elements.headOption.flatMap(_.file.name.headOption).getOrElse("unknown"),
      sourceLine = elements.headOption.flatMap(_.lineNumber).getOrElse(0),
      sourceCode = elements.headOption.map(_.code).getOrElse(""),
      sinkFile = file,
      sinkLine = line,
      sinkCode = sink.code,
      path = elements.map(e => s"line ${e.lineNumber.getOrElse(0)}: ${e.code.take(50)}").l
    )
  }

  // Verified - vulnerable!
  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = 0.90,
    reason = "User input flows directly to shell command execution",
    dataFlow = flowPath
  ))
}
