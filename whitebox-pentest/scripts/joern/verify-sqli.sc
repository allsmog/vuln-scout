// SQL Injection Verification Script
// Verifies if user input reaches database query without parameterization
//
// Usage: joern --script verify-sqli.sc --params cpgFile=app.cpg,file=login.ts,line=34

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int) = {
  importCpg(cpgFile)

  println(s"[*] Verifying SQL injection at $file:$line")

  // Define SQL-specific sinks
  val sqlSinkPattern = "query|execute|raw|rawQuery|knex|sequelize"

  // Define SQL-specific sanitizers (parameterization)
  val sqlSanitizerPattern = "prepare|parameterize|escape|sanitize|placeholder"

  // Find the target sink
  val targetSinks = cpg.call.name(sqlSinkPattern)
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.lineNumber.getOrElse(0) == line)
    .l

  if (targetSinks.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.0,
      reason = s"No SQL sink found at $file:$line"
    ))
    return
  }

  val sink = targetSinks.head

  // Define sources (user input)
  val sources = cpg.parameter.name(".*req.*|.*request.*|.*body.*|.*params.*|.*query.*")

  // Check if any source reaches this sink
  val flows = sink.argument.reachableBy(sources).l

  if (flows.isEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "No data flow from user input to SQL query"
    ))
    return
  }

  // Check for parameterized queries (placeholder pattern)
  val queryArg = sink.argument(1)
  val isParameterized = queryArg.code.headOption.exists { code =>
    code.contains("?") ||           // Positional placeholders
    code.contains("$1") ||          // PostgreSQL positional
    code.matches(".*:\\w+.*") ||    // Named placeholders :name
    code.contains("@")              // MSSQL parameters
  }

  if (isParameterized) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.90,
      reason = "Parameterized query detected - placeholders found in query string"
    ))
    return
  }

  // Check for sanitizer functions in the path
  val sanitizedFlows = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name(sqlSanitizerPattern))
    .l

  if (sanitizedFlows.size == flows.size && sanitizedFlows.nonEmpty) {
    val sanitizerNames = sink.argument.reachableBy(sources)
      .inAst.isCall.name(sqlSanitizerPattern)
      .name.l.distinct

    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.80,
      reason = s"Input is sanitized before reaching query",
      sanitizers = sanitizerNames
    ))
    return
  }

  // Check for type coercion (parseInt, Number, etc.)
  val typeCoerced = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("parseInt|parseFloat|Number|toInt"))
    .l

  if (typeCoerced.size == flows.size && typeCoerced.nonEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "Input is type-coerced to number before query - cannot inject SQL"
    ))
    return
  }

  // Check for string concatenation or template literals (vulnerable pattern)
  val hasStringConcat = queryArg.code.headOption.exists { code =>
    code.contains("+") ||           // String concatenation
    code.contains("${") ||          // Template literal
    code.contains("` + ")           // Mixed template + concat
  }

  // Build data flow path for output
  val flowPath = sink.argument.reachableByFlows(sources).l.headOption.map { flow =>
    val elements = flow.elements.l
    DataFlowPath(
      sourceFile = elements.headOption.flatMap(_.file.name.headOption).getOrElse("unknown"),
      sourceLine = elements.headOption.flatMap(_.lineNumber).getOrElse(0),
      sourceCode = elements.headOption.map(_.code).getOrElse(""),
      sinkFile = file,
      sinkLine = line,
      sinkCode = sink.code,
      path = elements.map(e => s"line ${e.lineNumber.getOrElse(0)}: ${e.code.take(50)}").l
    )
  }

  // Verified - vulnerable!
  val confidence = if (hasStringConcat) 0.95 else 0.85

  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = confidence,
    reason = if (hasStringConcat)
      "User input concatenated into SQL query without parameterization"
    else
      "User input flows to SQL query - verify parameterization manually",
    dataFlow = flowPath
  ))
}
