// SSRF Verification Script
// Verifies if user input reaches HTTP request functions
//
// Usage: joern --script verify-ssrf.sc --params cpgFile=app.cpg,file=proxy.ts,line=23

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int) = {
  importCpg(cpgFile)

  println(s"[*] Verifying SSRF at $file:$line")

  // HTTP request sinks
  val ssrfSinkPattern = "fetch|request|axios|got|needle|superagent|http.get|https.get|http.request|https.request|urllib|urlopen"

  // URL validation functions
  val validatorPattern = "URL|urlparse|isValidUrl|validateUrl|allowlist|whitelist"

  // Find the target sink
  val targetSinks = cpg.call.name(ssrfSinkPattern)
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.lineNumber.getOrElse(0) == line)
    .l

  if (targetSinks.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.0,
      reason = s"No HTTP request sink found at $file:$line"
    ))
    return
  }

  val sink = targetSinks.head

  // Define sources (user input, especially URL params)
  val sources = cpg.parameter.name(".*req.*|.*request.*|.*url.*|.*uri.*|.*target.*|.*host.*")

  // Check if any source reaches this sink
  val flows = sink.argument.reachableBy(sources).l

  if (flows.isEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "No data flow from user input to HTTP request"
    ))
    return
  }

  // Check for URL parsing/validation
  val validatedFlows = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name(validatorPattern))
    .l

  if (validatedFlows.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.50,
      reason = "URL validation detected - verify it checks protocol and hostname against allowlist"
    ))
    return
  }

  // Check for hardcoded base URL (safer pattern)
  val hasBaseUrl = sink.argument.code.headOption.exists { code =>
    code.contains("https://api.") ||
    code.contains("process.env.") ||
    code.startsWith("\"http")
  }

  if (hasBaseUrl) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.60,
      reason = "Hardcoded base URL detected - verify user input only controls path, not host"
    ))
    return
  }

  // Check for protocol restriction
  val hasProtocolCheck = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("startsWith|match|test"))
    .l

  if (hasProtocolCheck.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.50,
      reason = "Possible protocol check detected - verify it prevents file://, gopher://, etc."
    ))
    return
  }

  // Build data flow path
  val flowPath = sink.argument.reachableByFlows(sources).l.headOption.map { flow =>
    val elements = flow.elements.l
    DataFlowPath(
      sourceFile = elements.headOption.flatMap(_.file.name.headOption).getOrElse("unknown"),
      sourceLine = elements.headOption.flatMap(_.lineNumber).getOrElse(0),
      sourceCode = elements.headOption.map(_.code).getOrElse(""),
      sinkFile = file,
      sinkLine = line,
      sinkCode = sink.code,
      path = elements.map(e => s"line ${e.lineNumber.getOrElse(0)}: ${e.code.take(50)}").l
    )
  }

  // Verified - vulnerable!
  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = 0.90,
    reason = "User-controlled URL flows directly to HTTP request without validation",
    dataFlow = flowPath
  ))
}
