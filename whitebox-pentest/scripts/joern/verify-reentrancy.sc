// Reentrancy Verification Script for Solidity Smart Contracts
// Detects CEI (Checks-Effects-Interactions) pattern violations
//
// Vulnerability Pattern: External call BEFORE state change
//   (bool success, ) = msg.sender.call{value: amount}("");  // INTERACTION
//   balances[msg.sender] -= amount;                         // EFFECT (too late!)
//
// Safe Pattern: State change BEFORE external call (CEI)
//   balances[msg.sender] -= amount;                         // EFFECT first
//   (bool success, ) = msg.sender.call{value: amount}("");  // INTERACTION last
//
// Usage: joern --script verify-reentrancy.sc --params cpgFile=contracts.cpg,file=Vault.sol,line=45

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int) = {
  importCpg(cpgFile)

  println(s"[*] Verifying reentrancy vulnerability at $file:$line")

  // ============================================================================
  // STEP 1: Find the external call at the specified location
  // ============================================================================

  val externalCallPatterns = "call|delegatecall|staticcall|send|transfer"

  val targetCalls = cpg.call
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.lineNumber.getOrElse(0) == line)
    .filter(c => c.code.matches(s".*\\.($externalCallPatterns).*"))
    .l

  if (targetCalls.isEmpty) {
    // Try to find any call at that line
    val anyCalls = cpg.call
      .filter(c => c.file.name.headOption.getOrElse("").contains(file))
      .filter(c => c.lineNumber.getOrElse(0) == line)
      .l

    if (anyCalls.isEmpty) {
      printResult(VerificationResult(
        verdict = "NEEDS_REVIEW",
        confidence = 0.0,
        reason = s"No call found at $file:$line"
      ))
      return
    }

    // Check if it's an external call pattern
    val callCode = anyCalls.head.code
    if (!callCode.matches(s".*\\.($externalCallPatterns).*")) {
      printResult(VerificationResult(
        verdict = "NEEDS_REVIEW",
        confidence = 0.3,
        reason = s"Call at $file:$line is not an external call pattern: ${callCode.take(60)}"
      ))
      return
    }
  }

  val externalCall = targetCalls.headOption.getOrElse(
    cpg.call.filter(c => c.file.name.headOption.getOrElse("").contains(file))
      .filter(c => c.lineNumber.getOrElse(0) == line).l.head
  )

  println(s"[*] Found external call: ${externalCall.code.take(80)}")

  // ============================================================================
  // STEP 2: Find state-changing operations in the same function
  // ============================================================================

  // Get the containing function
  val containingMethod = externalCall.method.l.headOption

  if (containingMethod.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.4,
      reason = "Could not determine containing function"
    ))
    return
  }

  val method = containingMethod.get
  val externalCallLine = externalCall.lineNumber.getOrElse(0)

  println(s"[*] Containing function: ${method.name}")

  // State-changing patterns in Solidity:
  // - Storage writes (assignment to state variables, mappings, arrays)
  // - delete statements
  // - sstore in assembly

  val stateChangePatterns = List(
    "balances\\[.*\\]\\s*[-+]?=",      // balances[addr] = / -= / +=
    "balance\\[.*\\]\\s*[-+]?=",       // balance[addr] = / -= / +=
    "\\w+\\[.*\\]\\s*=",               // mapping assignment
    "delete\\s+\\w+",                   // delete statement
    "\\.push\\(",                       // array push
    "\\.pop\\(",                        // array pop
    "sstore\\(",                        // assembly storage write
    "owner\\s*=",                       // owner assignment
    "locked\\s*=",                      // mutex assignment
    "total\\w*\\s*[-+]?=",             // totalSupply, totalBalance, etc
    "amount\\s*[-+]?="                  // amount tracking
  )

  val stateChangeRegex = stateChangePatterns.mkString("|")

  // Find all state changes in the method
  val allAssignments = cpg.call
    .filter(c => c.method.name.headOption.getOrElse("") == method.name)
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.code.matches(s".*($stateChangeRegex).*"))
    .l

  // Also check for assignment operators
  val assignments = cpg.assignment
    .filter(a => a.method.name.headOption.getOrElse("") == method.name)
    .filter(a => a.file.name.headOption.getOrElse("").contains(file))
    .l

  println(s"[*] Found ${allAssignments.size} potential state changes, ${assignments.size} assignments")

  // ============================================================================
  // STEP 3: Check for CEI pattern violation (state change AFTER external call)
  // ============================================================================

  val stateChangesAfterCall = assignments.filter { a =>
    val assignLine = a.lineNumber.getOrElse(0)
    assignLine > externalCallLine
  }

  val potentialViolations = allAssignments.filter { c =>
    val changeLine = c.lineNumber.getOrElse(0)
    changeLine > externalCallLine
  }

  // ============================================================================
  // STEP 4: Check for reentrancy guards (mitigations)
  // ============================================================================

  val reentrancyGuards = List(
    "nonReentrant",           // OpenZeppelin modifier
    "ReentrancyGuard",        // OpenZeppelin contract
    "locked",                 // Common mutex pattern
    "mutex",                  // Mutex pattern
    "_notEntered",            // OZ internal
    "require.*locked",        // Manual lock check
    "require.*!locked"        // Manual lock check
  )

  val guardRegex = reentrancyGuards.mkString("|")

  // Check if function has reentrancy guard modifier
  val methodCode = method.code
  val hasGuard = methodCode.matches(s"(?s).*($guardRegex).*")

  // Also check for guard at file level
  val fileGuards = cpg.call
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.code.matches(s".*($guardRegex).*"))
    .l

  println(s"[*] Reentrancy guard detected: $hasGuard (file-level guards: ${fileGuards.size})")

  // ============================================================================
  // STEP 5: Determine verdict
  // ============================================================================

  if (hasGuard || fileGuards.nonEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "Reentrancy guard detected - function is protected",
      sanitizers = reentrancyGuards.filter(g => methodCode.contains(g) || fileGuards.exists(_.code.contains(g)))
    ))
    return
  }

  if (stateChangesAfterCall.isEmpty && potentialViolations.isEmpty) {
    // No state changes after external call - check if there are ANY state changes
    if (assignments.isEmpty && allAssignments.isEmpty) {
      printResult(VerificationResult(
        verdict = "NEEDS_REVIEW",
        confidence = 0.5,
        reason = "External call found but no state changes detected - manual review needed"
      ))
    } else {
      printResult(VerificationResult(
        verdict = "NEEDS_REVIEW",
        confidence = 0.6,
        reason = "State changes occur BEFORE external call (follows CEI pattern) - verify manually"
      ))
    }
    return
  }

  // Found state changes AFTER external call - this is the vulnerable pattern!
  val violationDetails = (stateChangesAfterCall ++ potentialViolations).map { v =>
    s"line ${v.lineNumber.getOrElse(0)}: ${v.code.take(50)}"
  }.distinct

  val dataFlow = DataFlowPath(
    sourceFile = file,
    sourceLine = externalCallLine,
    sourceCode = externalCall.code.take(100),
    sinkFile = file,
    sinkLine = stateChangesAfterCall.headOption.orElse(potentialViolations.headOption)
      .flatMap(_.lineNumber).getOrElse(0),
    sinkCode = stateChangesAfterCall.headOption.orElse(potentialViolations.headOption)
      .map(_.code.take(100)).getOrElse(""),
    path = List(
      s"line $externalCallLine: EXTERNAL CALL - ${externalCall.code.take(50)}",
      s"... state changes after call ..."
    ) ++ violationDetails
  )

  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = 0.90,
    reason = s"CEI VIOLATION: ${violationDetails.size} state change(s) found AFTER external call at line $externalCallLine. " +
             "This is the classic reentrancy vulnerability pattern. " +
             "External call can reenter before state is updated.",
    dataFlow = Some(dataFlow)
  ))
}

// ============================================================================
// ADDITIONAL HELPER: Scan entire file for reentrancy patterns
// ============================================================================

@main def scanFile(cpgFile: String, file: String) = {
  importCpg(cpgFile)

  println(s"[*] Scanning $file for reentrancy patterns")

  val externalCallPatterns = "call|delegatecall|staticcall|send|transfer"

  // Find all external calls in file
  val externalCalls = cpg.call
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.code.matches(s".*\\.($externalCallPatterns).*"))
    .l

  println(s"[*] Found ${externalCalls.size} external calls")

  externalCalls.foreach { call =>
    val line = call.lineNumber.getOrElse(0)
    println(s"\n[!] External call at line $line: ${call.code.take(60)}")
    println(s"    Method: ${call.method.name.headOption.getOrElse("unknown")}")
  }

  if (externalCalls.isEmpty) {
    println("[+] No external calls found - file appears safe from reentrancy")
  } else {
    println(s"\n[!] Review ${externalCalls.size} external call(s) for CEI pattern compliance")
  }
}
