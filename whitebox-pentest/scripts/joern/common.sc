// Common utilities for Joern verification scripts
// Used by all verify-*.sc scripts

import io.joern.dataflowengineoss.language._
import io.joern.dataflowengineoss.queryengine.EngineContext
import scala.util.{Try, Success, Failure}

// Initialize data flow engine
implicit val engineContext: EngineContext = EngineContext()

// ============================================================================
// SOURCE PATTERNS - User input entry points by framework
// ============================================================================

object Sources {
  // Express.js / Node.js
  val expressPatterns = "req|request|params|query|body|headers|cookies"

  // Generic HTTP
  val httpPatterns = "request|input|userInput|data|payload"

  // All sources combined
  val allPatterns = s"$expressPatterns|$httpPatterns"

  def getHttpSources(cpg: Cpg) = {
    cpg.parameter.name(s".*($allPatterns).*")
  }

  def getFieldAccess(cpg: Cpg) = {
    cpg.fieldAccess.code(s".*($allPatterns).*")
  }
}

// ============================================================================
// SINK PATTERNS - Dangerous functions by vulnerability type
// ============================================================================

object Sinks {
  // SQL Injection
  val sqlSinks = "query|execute|raw|rawQuery|sequelize|knex"

  // Command Injection
  val cmdSinks = "execSync|spawn|spawnSync|execFile|system|popen"

  // XSS - DOM manipulation sinks
  val xssSinks = "send|write|render|html|innerHTML|writeln"

  // Path Traversal
  val pathSinks = "readFile|readFileSync|writeFile|createReadStream|createWriteStream|unlink"

  // SSRF
  val ssrfSinks = "fetch|request|axios|http.get|https.get|urllib"

  // NoSQL Injection
  val nosqlSinks = "find|findOne|findById|updateOne|deleteOne|aggregate"

  // Deserialization (language-specific unsafe loaders)
  val deserSinks = "parse|load|loads|unserialize|deserialize|readObject"
}

// ============================================================================
// SANITIZER PATTERNS - Security functions that break attack chains
// ============================================================================

object Sanitizers {
  // SQL - Parameterization
  val sqlSanitizers = "prepare|parameterize|escape|sanitize"

  // XSS - Encoding
  val xssSanitizers = "escapeHtml|htmlEncode|encode|sanitize|DOMPurify"

  // Path - Normalization
  val pathSanitizers = "resolve|normalize|basename|realpath"

  // Command - Validation
  val cmdSanitizers = "parseInt|parseFloat|Number|allowlist|whitelist"

  // Generic
  val allSanitizers = "sanitize|escape|encode|validate|filter|clean"
}

// ============================================================================
// VERIFICATION RESULT
// ============================================================================

case class VerificationResult(
  verdict: String,           // VERIFIED, FALSE_POSITIVE, NEEDS_REVIEW
  confidence: Double,        // 0.0 - 1.0
  reason: String,
  dataFlow: Option[DataFlowPath] = None,
  sanitizers: List[String] = List.empty
)

case class DataFlowPath(
  sourceFile: String,
  sourceLine: Int,
  sourceCode: String,
  sinkFile: String,
  sinkLine: Int,
  sinkCode: String,
  path: List[String]
)

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

def isTestFile(fileName: String): Boolean = {
  fileName.contains("test") ||
  fileName.contains("spec") ||
  fileName.contains("mock") ||
  fileName.contains("__tests__") ||
  fileName.contains("fixtures")
}

def isVendorFile(fileName: String): Boolean = {
  fileName.contains("node_modules") ||
  fileName.contains("vendor") ||
  fileName.contains("third_party")
}

def shouldExclude(fileName: String): Boolean = {
  isTestFile(fileName) || isVendorFile(fileName)
}

// Format location for output
def formatLocation(file: String, line: Int): String = {
  s"$file:$line"
}

// ============================================================================
// OUTPUT FORMATTING
// ============================================================================

def toJson(result: VerificationResult): String = {
  val dataFlowJson = result.dataFlow.map { df =>
    s"""
    |  "dataFlow": {
    |    "source": {"file": "${df.sourceFile}", "line": ${df.sourceLine}, "code": "${escapeJson(df.sourceCode)}"},
    |    "sink": {"file": "${df.sinkFile}", "line": ${df.sinkLine}, "code": "${escapeJson(df.sinkCode)}"},
    |    "path": [${df.path.map(p => s""""${escapeJson(p)}"""").mkString(", ")}]
    |  },""".stripMargin
  }.getOrElse("")

  val sanitizersJson = if (result.sanitizers.nonEmpty) {
    s""""sanitizers": [${result.sanitizers.map(s => s""""$s"""").mkString(", ")}],"""
  } else ""

  s"""{
  |  "verdict": "${result.verdict}",
  |  "confidence": ${result.confidence},
  |  "reason": "${escapeJson(result.reason)}",
  |$dataFlowJson
  |$sanitizersJson
  |  "method": "joern-cpg"
  |}""".stripMargin.replaceAll("\n\\s*\n", "\n")
}

def escapeJson(s: String): String = {
  s.replace("\\", "\\\\")
   .replace("\"", "\\\"")
   .replace("\n", "\\n")
   .replace("\r", "\\r")
   .replace("\t", "\\t")
}

// Print result as JSON
def printResult(result: VerificationResult): Unit = {
  println(toJson(result))
}
