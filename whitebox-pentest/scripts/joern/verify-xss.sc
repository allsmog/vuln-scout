// XSS Verification Script
// Verifies if user input reaches HTML output without encoding
//
// Usage: joern --script verify-xss.sc --params cpgFile=app.cpg,file=profile.ts,line=89

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int) = {
  importCpg(cpgFile)

  println(s"[*] Verifying XSS at $file:$line")

  // HTML output sinks
  val xssSinkPattern = "send|write|render|html|innerHTML|writeln|res.send|res.write"

  // HTML encoding functions
  val encoderPattern = "escapeHtml|htmlEncode|encode|sanitize|DOMPurify|xss|escape"

  // Find the target sink
  val targetSinks = cpg.call.name(xssSinkPattern)
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.lineNumber.getOrElse(0) == line)
    .l

  if (targetSinks.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.0,
      reason = s"No HTML output sink found at $file:$line"
    ))
    return
  }

  val sink = targetSinks.head

  // Define sources (user input)
  val sources = cpg.parameter.name(".*req.*|.*request.*|.*body.*|.*params.*|.*query.*")

  // Check if any source reaches this sink
  val flows = sink.argument.reachableBy(sources).l

  if (flows.isEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "No data flow from user input to HTML output"
    ))
    return
  }

  // Check for HTML encoding
  val encodedFlows = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name(encoderPattern))
    .l

  if (encodedFlows.size == flows.size && encodedFlows.nonEmpty) {
    val encoderNames = sink.argument.reachableBy(sources)
      .inAst.isCall.name(encoderPattern)
      .name.l.distinct

    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = s"HTML encoding detected before output",
      sanitizers = encoderNames
    ))
    return
  }

  // Check for JSON response (Content-Type: application/json)
  val isJsonResponse = sink.inAst.isCall.name("json").l.nonEmpty

  if (isJsonResponse) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.90,
      reason = "JSON response - browser will not execute as HTML"
    ))
    return
  }

  // Check for template engine auto-escaping (common in Express/EJS/Pug)
  val usesTemplate = sink.name == "render"

  if (usesTemplate) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.50,
      reason = "Template render detected - verify template engine auto-escapes (EJS uses <%- for raw output)"
    ))
    return
  }

  // Check for Content-Type header setting
  val hasContentType = cpg.call.name("setHeader|type|contentType")
    .where(_.argument.code(".*text/plain.*|.*application/json.*"))
    .l

  if (hasContentType.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.60,
      reason = "Non-HTML Content-Type may be set - verify response type"
    ))
    return
  }

  // Build data flow path
  val flowPath = sink.argument.reachableByFlows(sources).l.headOption.map { flow =>
    val elements = flow.elements.l
    DataFlowPath(
      sourceFile = elements.headOption.flatMap(_.file.name.headOption).getOrElse("unknown"),
      sourceLine = elements.headOption.flatMap(_.lineNumber).getOrElse(0),
      sourceCode = elements.headOption.map(_.code).getOrElse(""),
      sinkFile = file,
      sinkLine = line,
      sinkCode = sink.code,
      path = elements.map(e => s"line ${e.lineNumber.getOrElse(0)}: ${e.code.take(50)}").l
    )
  }

  // Verified - vulnerable!
  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = 0.85,
    reason = "User input flows to HTML output without encoding",
    dataFlow = flowPath
  ))
}
