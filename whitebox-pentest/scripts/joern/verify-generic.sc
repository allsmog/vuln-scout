// Generic Source-to-Sink Verification Script
// Verifies data flow for any vulnerability type
//
// Usage: joern --script verify-generic.sc --params cpgFile=app.cpg,file=handler.ts,line=45,sinkPattern=query

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int, sinkPattern: String = ".*") = {
  importCpg(cpgFile)

  println(s"[*] Verifying data flow at $file:$line (sink pattern: $sinkPattern)")

  // Find the target sink
  val targetSinks = if (sinkPattern == ".*") {
    // Find any call at the specified location
    cpg.call
      .filter(c => c.file.name.headOption.getOrElse("").contains(file))
      .filter(c => c.lineNumber.getOrElse(0) == line)
      .l
  } else {
    cpg.call.name(sinkPattern)
      .filter(c => c.file.name.headOption.getOrElse("").contains(file))
      .filter(c => c.lineNumber.getOrElse(0) == line)
      .l
  }

  if (targetSinks.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.0,
      reason = s"No matching call found at $file:$line"
    ))
    return
  }

  val sink = targetSinks.head
  println(s"[*] Found sink: ${sink.name} - ${sink.code.take(80)}")

  // Define sources (all user input patterns)
  val sources = cpg.parameter.name(".*req.*|.*request.*|.*body.*|.*params.*|.*query.*|.*input.*|.*data.*")

  // Check if any source reaches this sink
  val flows = sink.argument.reachableBy(sources).l

  if (flows.isEmpty) {
    // Also check field access patterns (req.body.x)
    val fieldSources = cpg.fieldAccess.code(".*req.*|.*request.*")
    val fieldFlows = sink.argument.reachableBy(fieldSources).l

    if (fieldFlows.isEmpty) {
      printResult(VerificationResult(
        verdict = "FALSE_POSITIVE",
        confidence = 0.80,
        reason = "No data flow from user input to this sink"
      ))
      return
    }
  }

  // Check for any common sanitizers
  val sanitizerPattern = "sanitize|escape|encode|validate|filter|clean|prepare|parameterize|normalize|basename"

  val sanitizedFlows = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name(sanitizerPattern))
    .l

  if (sanitizedFlows.size == flows.size && sanitizedFlows.nonEmpty) {
    val sanitizerNames = sink.argument.reachableBy(sources)
      .inAst.isCall.name(sanitizerPattern)
      .name.l.distinct

    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.60,
      reason = s"Sanitization detected in data flow path",
      sanitizers = sanitizerNames
    ))
    return
  }

  // Check for type coercion
  val typeCoerced = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("parseInt|parseFloat|Number|toInt|Boolean"))
    .l

  if (typeCoerced.size == flows.size && typeCoerced.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.70,
      reason = "Type coercion detected - input converted to safe type"
    ))
    return
  }

  // Build data flow path
  val flowPath = sink.argument.reachableByFlows(sources).l.headOption.map { flow =>
    val elements = flow.elements.l
    DataFlowPath(
      sourceFile = elements.headOption.flatMap(_.file.name.headOption).getOrElse("unknown"),
      sourceLine = elements.headOption.flatMap(_.lineNumber).getOrElse(0),
      sourceCode = elements.headOption.map(_.code).getOrElse(""),
      sinkFile = file,
      sinkLine = line,
      sinkCode = sink.code,
      path = elements.map(e => s"line ${e.lineNumber.getOrElse(0)}: ${e.code.take(50)}").l
    )
  }

  // Verified - data flow exists
  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = 0.75,
    reason = s"User input flows to ${sink.name}() without obvious sanitization",
    dataFlow = flowPath
  ))
}
