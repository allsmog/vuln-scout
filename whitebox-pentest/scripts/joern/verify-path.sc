// Path Traversal Verification Script
// Verifies if user input reaches file operations without normalization
//
// Usage: joern --script verify-path.sc --params cpgFile=app.cpg,file=download.ts,line=56

import $file.common, common._

@main def verify(cpgFile: String, file: String, line: Int) = {
  importCpg(cpgFile)

  println(s"[*] Verifying path traversal at $file:$line")

  // File operation sinks
  val pathSinkPattern = "readFile|readFileSync|writeFile|writeFileSync|createReadStream|createWriteStream|unlink|unlinkSync|stat|statSync|access|accessSync|open|openSync"

  // Path normalization functions
  val normalizerPattern = "resolve|normalize|basename|realpath|realpathSync"

  // Find the target sink
  val targetSinks = cpg.call.name(pathSinkPattern)
    .filter(c => c.file.name.headOption.getOrElse("").contains(file))
    .filter(c => c.lineNumber.getOrElse(0) == line)
    .l

  if (targetSinks.isEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.0,
      reason = s"No file operation sink found at $file:$line"
    ))
    return
  }

  val sink = targetSinks.head

  // Define sources (user input, especially path/filename params)
  val sources = cpg.parameter.name(".*req.*|.*request.*|.*path.*|.*file.*|.*name.*")

  // Check if any source reaches this sink
  val flows = sink.argument.reachableBy(sources).l

  if (flows.isEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.85,
      reason = "No data flow from user input to file operation"
    ))
    return
  }

  // Check for path normalization
  val normalizedFlows = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name(normalizerPattern))
    .l

  if (normalizedFlows.size == flows.size && normalizedFlows.nonEmpty) {
    val normalizerNames = sink.argument.reachableBy(sources)
      .inAst.isCall.name(normalizerPattern)
      .name.l.distinct

    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.60,
      reason = s"Path normalization detected - verify it prevents traversal",
      sanitizers = normalizerNames
    ))
    return
  }

  // Check for basename extraction (safe - strips directory components)
  val hasBasename = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("basename"))
    .l

  if (hasBasename.size == flows.size && hasBasename.nonEmpty) {
    printResult(VerificationResult(
      verdict = "FALSE_POSITIVE",
      confidence = 0.90,
      reason = "basename() extracts filename only - directory traversal prevented"
    ))
    return
  }

  // Check for path prefix validation (startsWith check)
  val hasPrefixCheck = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("startsWith|indexOf|includes"))
    .l

  if (hasPrefixCheck.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.50,
      reason = "Possible path prefix validation - verify it checks after normalization"
    ))
    return
  }

  // Check for traversal sequence filtering
  val hasTraversalFilter = sink.argument.reachableBy(sources)
    .where(_.inAst.isCall.name("replace|replaceAll"))
    .l

  if (hasTraversalFilter.nonEmpty) {
    printResult(VerificationResult(
      verdict = "NEEDS_REVIEW",
      confidence = 0.40,
      reason = "String replacement detected - blacklist filtering is often bypassable"
    ))
    return
  }

  // Build data flow path
  val flowPath = sink.argument.reachableByFlows(sources).l.headOption.map { flow =>
    val elements = flow.elements.l
    DataFlowPath(
      sourceFile = elements.headOption.flatMap(_.file.name.headOption).getOrElse("unknown"),
      sourceLine = elements.headOption.flatMap(_.lineNumber).getOrElse(0),
      sourceCode = elements.headOption.map(_.code).getOrElse(""),
      sinkFile = file,
      sinkLine = line,
      sinkCode = sink.code,
      path = elements.map(e => s"line ${e.lineNumber.getOrElse(0)}: ${e.code.take(50)}").l
    )
  }

  // Verified - vulnerable!
  printResult(VerificationResult(
    verdict = "VERIFIED",
    confidence = 0.90,
    reason = "User input flows to file operation without path normalization",
    dataFlow = flowPath
  ))
}
